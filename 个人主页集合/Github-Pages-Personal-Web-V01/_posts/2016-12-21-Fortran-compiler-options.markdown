---
layout:     post
title:      "Fortran编译器选项"
subtitle:   "Fortran compiler options"
date:       2016-12-21
author:     "QQF"
header-img: "img/home-bg.png"
catalog: true
tags:
    - 编译器
    - Fortran
---

## 命令语法

`f95 [options] list_of_files additional_options`<br/>
方括号内的项指示可选参数。方括号不是命令的一部分。options 是前面带有短划线 (–) 的选项关键字列表。一些关键字选项将列表中的下一项作为参数。list_of_files 是由空格分隔的源文件名、目标文件名或库文件名的列表。此外，有一些选项（例如，-B、-l 和 -L）必须出现在源文件列表之后，而且这些选项可以包括其他文件列表。

## 选项语法

- ## 选项语法
![img](/img/in-post/2016-12-21-Fortran-compiler-options/01.png)

- ## 选项的印刷表示法
![img](/img/in-post/2016-12-21-Fortran-compiler-options/02.png)
括号、管道符和省略号是在选项描述中使用的元字符，它们不是选项本身的一部分。
选项的一些常规准则如下：<br/>
–lx 是用于与库 libx.a 链接的选项。将 -lx 放在文件名列表之后以确保搜索顺序库，始终是较为安全之举。<br/>
通常，按从左向右的顺序处理编译器选项，允许选择性地覆盖宏选项（包括其他选项的选项）。此规则不适用于链接程序选项。但是，当某些选项（例如 -I、-L 和 -R）在同一命令行上重复出现时，这些选项将累加值，而不是覆盖前面的值。<br/>
在可选选项列表（例如 -xhasc[={yes\|no}]）中，所列的第一个选项是出现在命令行上的选项标志不带值时所假定的值。例如，-xhasc 与 -xhasc=yes 等效。<br/>
源文件、目标文件和库按它们在命令行上出现的顺序编译并链接。

## 选项摘要
![img](/img/in-post/2016-12-21-Fortran-compiler-options/03.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/04.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/05.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/06.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/07.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/08.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/09.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/10.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/11.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/12.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/13.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/14.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/15.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/16.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/17.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/18.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/19.png)

- ## 常用选项
![img](/img/in-post/2016-12-21-Fortran-compiler-options/20.png)

- ## 宏标志
> 某些选项标志是可扩展为由其他标志组成的特定集合的宏。之所以提供这些选项标志，是为了便于指定通常一起用来选择某项功能的多个选项。命令行上跟在宏标志后面的设置将覆盖或增加宏扩展。

![img](/img/in-post/2016-12-21-Fortran-compiler-options/21.png)

- ## 向后兼容性和传统选项
> 提供以下选项的目的是为了与早期发行版的编译器和某些 Fortran 传统功能向后兼容。建议在生成可移植的 Fortran 程序时不要使用这些选项标志。

![img](/img/in-post/2016-12-21-Fortran-compiler-options/22.png)

- ## 已过时的选项标志
> 下面的选项被认为是已过时的，不应使用它们。在编译器的以后发行版本中可能会删除这些选项。

![img](/img/in-post/2016-12-21-Fortran-compiler-options/23.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/24.png)

## 选项参考

> 本节说明了所有的 f95 编译器命令行选项标志，包括各种风险、限制、警告、交互作用、示例和其他详细信息。除非另行指明，否则每个选项在 SPARC 和 x64/x86 平台上都有效。仅在 SPARC 平台上有效的选项标志标有 (SPARC)。仅在 x64/x86 平台上有效的选项标志标有 (x86)。标有（已过时）的选项标志已过时，不应使用。在许多情况下，它们已经被其他应该使用的选项或标志取代。

- ## `–a`

（已过时）使用 tcov 按基本块进行分析，这是旧用法。这是 tcov 的基本块分析的旧用法。有关新式分析的信息，请参见 -xprofile=tcov；有关更多详细信息，请参见 tcov(1) 手册页。

- ## `–aligncommon[={ 1|2|4|8| 16}]`

指定通用块和标准数值序列类型中数据的对齐。<br/>
此值表示通用块和标准数值序列类型中数据元素的最大对齐（以字节为单位）。<br/>
注 –<br/>
标准数值序列类型是包含 SEQUENCE 语句以及唯一的缺省组件数据类型（INTEGER、REAL、DOUBLEPRECISION 和 COMPLEX，不带KIND= 或 * size）的派生类型。任何其他类型（如 REAL*8）将使类型成为非标准类型。<br/>
例如，-aligncommon=4 会将自然对齐方式为 4 字节或大于 4 字节的数据元素与 4 字节边界对齐。<br/>
该选项不影响自然对齐方式小于指定大小的数据。<br/>
如果不使用 -aligncommon，则编译器会将通用块和数值序列类型中的元素与（最多）4 字节边界对齐。<br/>
如果指定不带值的 -aligncommon，则缺省值为 1－所有的通用块和数值序列类型元素都与字节边界对齐（元素之间无填充）。<br/>
在未启用 64 位的平台上，-aligncommon=16 恢复为 -aligncommon=8。<br/>
不要将 -aligncommon=1 与 -xmemalign 一起使用，因为这些声明会发生冲突，在某些平台和配置上可能会引发段故障。

- ## `–ansi`

标识许多非标准扩展。如果在源代码中使用非标准 Fortran 扩展，则会发出警告消息。

- ## `–arg=local`

通过 ENTRY 语句保留实际参数。<br/>
在使用此选项编译具有替换入口点的子程序时，f95 将使用复制/恢复功能保留哑元参数和实际参数之间的关联。<br/>
提供此选项的目的是与传统的 Fortran 77 程序兼容。依赖此选项的代码是非标准的。

- ## `–autopar`

启用自动循环并行化。<br/>
查找相应的循环并使之并行化，以便在多个处理器上并行运行。分析循环以了解迭代间的数据依赖性并重构循环。如果未将优化级别指定为 -O3或更高，则会将其自动提升到 -O3。<br/>
在使用任何并行化选项（包括 -autopar）时，也要指定 -stackvar 选项。当使用 -autopar 时，-stackvar 选项可提供更好的性能，因为它可允许优化器为并行检测其他机会。有关如何为主线程栈和从线程栈设置大小的信息，请参见 -stackvar 选项描述。<br/>
如果程序已经包含对 libthread 线程库的显式调用，请避免使用 -autopar。请参见–mt中的注释。<br/>
-autopar 选项不适用于单处理器系统，而且已编译代码的运行速度通常会更慢。<br/>
要在多线程环境中运行已并行化的程序，必须在执行之前设置 PARALLEL（或 OMP_NUM_THREADS）环境变量。这会将程序可以创建的最大线程数通知给运行时系统。缺省值为 1。通常会将 PARALLEL 或 OMP_NUM_THREADS 变量设置为目标平台上可用的虚拟处理器数，该值可使用 Solaris psrinfo(1) 命令确定。<br/>
如果使用 -autopar 并在同一步骤中进行编译和链接，则会自动链接多线程库和线程安全的 Fortran 运行时库。如果使用 -autopar 并在不同的步骤中进行编译和链接，则还必须使用 -autopar 进行链接以确保链接相应的库。<br/>
—reduction 选项与 —autopar 一起使用也可能会很有用。<br/>
有关并行化的更多信息，请参阅《Fortran 编程指南》。有关用户控制的显式并行化，则使用 OpenMP 指令和 —xopenmp 选项。

- ## –B{static| dynamic}

首选动态库链接或要求静态库链接。<br/>
在 -B 与 dynamic 或 static 之间不允许有空格。如果未指定 -B，则缺省值为 -Bdynamic。<br/>
–Bdynamic： 首选动态链接（试图找到共享库）。<br/>
–Bstatic： 要求静态链接（无共享库）。<br/>
另请注意：<br/>
如果指定 static，但是链接程序仅找到动态库，则不链接该库，同时发出警告“未找到库”。<br/>
如果指定 dynamic，但链接程序仅找到静态版本的库，则链接该库，并且不发出警告。<br/>
您可以在命令行上切换 -Bstatic 和 -Bdynamic。也就是说，通过在命令行上指定 -Bstatic 和 -Bdynamic 任意多次，可以静态链接一些库并动态链接一些库，如下所示：<br/>
`f95 prog.f -Bdynamic -lwells -Bstatic -lsurface`<br/>
这些是加载器和链接程序选项。在不同的步骤中使用编译命令的 -Bx 选项进行编译和链接时，将要求在链接步骤中也使用该选项。<br/>
不能在命令行上同时指定 -Bdynamic 和 -dn，因为 -dn 禁用动态库的链接。<br/>
在 64 位 Solaris 环境中，许多系统库仅作为共享动态库提供，其中包括 libm.so 和 libc.so（不提供 libm.a 和 libc.a）。这意味着，在 64 位 Solaris 环境中，-Bstatic 和 -dn 可能会导致链接错误。这些情况下应用程序必须与动态库链接。<br/>
不推荐同时使用静态 Fortran 运行时系统库和动态 Fortran 运行时系统库，因为这会导致链接程序错误或无提示的数据损坏。始终保持同最新的共享动态 Fortran 运行时系统库的链接。<br/>
有关静态库和动态库的更多信息，请参见《Fortran 编程指南》。

- ## `–C`

检查数组引用以查找超出范围的下标并在运行时检查一致性。<br/>
如果数组下标超过所声明的大小，可能会导致意外结果（包括段故障）。-C 选项检查源代码中和执行过程中可能的数组下标违规。-C 还添加了对数组语法表达式中数组一致性的运行时检查。<br/>
指定 -C 可能会使可执行文件更大。<br/>
如果使用 -C 选项，则会将数组下标违规视为错误。如果在编译过程中检测到源代码中存在数组下标范围违规，则会将它视为编译错误。<br/>
如果只能在运行时确定数组下标违规，则编译器会将范围检查代码生成到可执行程序中。这可能导致执行时间增加。因此，应该在开发和调试程序时启用完全数组下标检查，然后重新编译最后产生的可执行程序，而不必进行下标检查。

- ## `–c`

仅编译；生成目标 .o 文件，但禁止链接。<br/>
针对每个源文件编译 .o 文件。如果仅编译一个源文件，则可以使用 -o 选项来指定所写入的 .o 文件的名称。

- ## `–copyargs`

允许为常量参数赋值。<br/>
允许子程序更改其为常量的哑元参数。提供此选项只是为了允许编译和执行传统代码而不出现运行时错误。<br/>
在不使用 -copyargs 的情况下，如果将常量参数传递给子例程，然后在子例程内尝试更改该常量，则运行将终止。<br/>
在使用 -copyargs 的情况下，如果将常量参数传递给子例程，然后在子例程内更改该常量，则运行不一定终止。<br/>
当然，除非使用 -copyargs 进行编译，否则终止的代码是不符合 Fortran 标准的。此外，这样的代码通常是不可预知的。

- ## `–Dname[ =def]`

为预处理程序定义符号 name。<br/>
此选项仅适用于 .F、.F90、.F95 和 .F03 源文件。<br/>
–Dname=def 将 name 定义为具有值 def<br/>
–Dname 将 name 定义为 1<br/>
在命令行上，此选项将定义 name，就如同<br/>
`#define name[=def]`<br/>
已经出现在源文件中。如果未指定 =def，则名称 name 的值定义为 1。宏符号 name 会传递到预处理程序 fpp（或 cpp－请参见 -xpp 选项）进行扩展。<br/>
预定义的宏符号具有两个前导下划线。Fortran 语法可能不支持这些宏的实际值－它们只应出现在 fpp 或 cpp 预处理程序指令中。（请注意两个前导下划线。）<br/>
产品版本是在 _ _SUNPRO_F90 和 _ _SUNPRO_F95 中预定义的（用十六进制表示）。例如，对于 Sun Studio 12 发行版，_ _SUNPRO_F95 为 0x830。<br/>
以下宏是在相应系统上预定义的：<br/>
_ _sparc、_ _unix、_ _sun、_ _SVR4、__i386、_ _SunOS_5_6、_ _SunOS_5_7、_ _SunOS_5_8、_ _SunOS_5_9 和 _ _SunOS_5_10<br/>
例如，值 _ _sparc 是在 SPARC 系统上定义的。<br/>
以下预定义值不带下划线，但是在以后的发行版中可能会删除这些值： sparc、unix 和 sun。<br/>
在 SPARC V9 系统上，还定义了 _ _sparcv9 宏。<br/>
在 64 位 x86 系统上，定义了宏 __amd64 和 __x86_64。<br/>
使用详细选项 (-v) 进行编译可查看由编译器创建的定义。<br/>
您可以在类似如下的预处理程序条件中使用这些值：<br/>
`#ifdef _ _sparc`
缺省情况下，f95 使用 fpp(1) 预处理程序。与 C 预处理程序 cpp(1) 一样，fpp 会扩展源代码宏并允许对代码进行条件编译。与 cpp 不同的是，fpp 能够识别 Fortran 语法，并作为首选的 Fortran 预处理程序。使用 -xpp=cpp 标志可以强制编译器明确使用 cpp 而非 fpp。

- ## `–dalign`

对齐 COMMON 块和标准数值序列类型，并生成速度更快的多字装入/存储。<br/>
此标志可更改 COMMON 块、数值序列类型和 EQUIVALENCE 类中的数据布局，并使编译器能够为该数据生成速度更快的多字装入/存储。<br/>
数据布局效果与 -f 标志的效果相同： COMMON 块和 EQUIVALENCE 类中的双精度和四精度数据在内存中根据其“自然”对齐方式（即，与 8 字节边界对齐）进行布局；如果在 64 位环境中使用 -m64 进行编译，则四精度数据与 16 字节边界对齐。缺省情况下，按 4 字节边界对齐 COMMON 块中的数据。还允许编译器采用自然对齐方式并生成速度更快的多字装入/存储以引用数据。<br/>
在 SPARC 处理器上，如果结合使用 -dalign 和 -xtypemap=real:64,double:64,integer:64，还会导致 64 位整数变量进行双字对齐。<br/>
注 –<br/>
-dalign 可能导致数据以非标准方式对齐，从而使 EQUIVALENCE 或 COMMON 中的变量出现问题，并可能在需要 -dalign 的情况下使程序变为不可移植。<br/>
-dalign 是一个宏，它等效于：<br/>
-xmemalign=8s -aligncommon=16（在 SPARC 平台上）<br/>
-aligncommon=8（在 32 位 x86 平台上）<br/>
-aligncommon=16（在 64 位 x86 平台上）。<br/>
如果使用 -dalign 编译某个子程序，请使用 -dalign 编译该程序的所有子程序。此选项包含在 -fast 选项中。<br/>
请注意，因为 -dalign 调用 -aligncommon，所以此选项还影响标准数值序列类型。请参见–aligncommon[={ 1\|2\|4\|8\|16}]

- ## `–dbl_align_all[= {yes|no}]`

强制与 8 字节边界对齐数据。<br/>
值为 yes 或 no。如果是 yes，所有变量将与 8 字节边界对齐。缺省值为 -dbl_align_all=no。<br/>
在 64 位环境中使用 -m64 进行编译时，此标志会使四精度数据与 16 字节边界对齐。<br/>
此标志不改变 COMMON 块或用户定义结构中的数据的布局。<br/>
与 -dalign 一起使用可以提高多字装入/存储的效率。<br/>
如果使用了此标志，则所有例程都必须使用此标志进行编译。

- ## `–depend[={ yes|no}]`

分析循环以了解迭代间数据的依赖性并重构循环。 循环重构包括循环交换、循环合并、标量替换和“死”数组赋值消除。<br/>
在 SPARC 平台上，对所有 -xO3 及更高优化级别打开 -xdepend 选项，对较低的优化级别则关闭该选项。此外，-xdepend 的显式设置会覆盖任何隐式设置。<br/>
在 x86 平台上，如果优化级别不是 -xO3 或更高级别，编译器会将优化级别提高到 -xO3 并发出警告。<br/>
如果未指定 -xdepend，缺省设置将为 -xdepend=no，该设置表示编译器不分析循环以了解数据依赖性。如果指定 -xdepend 但未指定参数，编译器会将此选项设置为 -xdepend=yes，该设置表示编译器将分析循环以了解数据依赖性。<br/>
-xautopar 中包括依赖性分析。依赖性分析在编译时完成。依赖性分析在单处理器系统中可能很有用。不过，如果在单处理器系统上尝试使用 -xdepend，不应该再指定 -xautopar，否则，会针对多处理器系统执行 -xdepend 优化。

- ## `–dn`

禁止动态库。请参见–d{y\|n}。

- ## `–dryrun`

显示由 f95 命令行驱动程序生成的命令，但不进行编译。<br/>
此选项在调试时非常有用，它显示编译器为执行编译将调用的命令和子选项。

- ## `–d{y|n}`

允许或禁止对整个可执行文件使用动态库。<br/>
–dy： 值为 Yes，允许使用动态/共享库。<br/>
–dn：值为 No，不允许使用动态/共享库。<br/>
如果未指定，则缺省值为 -dy。<br/>
与 -Bx 不同，此选项适用于整个可执行文件，并且只需在命令行上出现一次。<br/>
–dy\|–dn 是加载器和链接程序选项。如果使用这些选项在不同的步骤中编译和链接，则在链接步骤中需要相同选项。<br/>
在 64 位 Solaris 环境中，许多系统库不只是作为共享动态库提供，其中包括 libm.so 和 libc.so（不提供 libm.a 和 libc.a）。这意味着，-dn 和 -Bstatic 可能会导致在 64 位 Solaris 环境、32 位 x86 Solaris 平台以及所有 32 位 Solaris 平台（从 Solaris 10 发行版开始）中出现链接错误。这些情况下应用程序必须与动态库链接。

- ## `–e`

接受扩展长度的输入源代码行。<br/>
扩展的源代码行中最多可以包含 132 个字符。编译器会在右侧用结尾空白一直填充到第 132 列。如果在使用 -e 进行编译时使用续行，则不跨行拆分字符常量；否则，可能会在常量中插入不必要的空白。

- ## `–erroff[={ %all|%none|taglist}]`

禁止由标记名称列出的警告消息。<br/>
禁止显示在标记名称的逗号分隔列表 taglist 中指定的警告消息。如果选项值为 %all，则禁止显示所有警告，这在效果上等同于 -w 选项。 如果选项值为 %none，则不禁止显示任何警告。不带参数的 —erroff 与 —erroff=%all 等效。<br/>
示例：<br/>
`f95 -erroff=WDECL_LOCAL_NOTUSED ink.f`<br/>
使用 -errtags 选项可查看与警告消息关联的标记名称。

- ## `–errtags[={ yes|no}]`

与每个警告消息一起显示消息标记。<br/>
如果使用 -errtags=yes，编译器的内部错误标记名称将与警告消息一起显示。-errtags 本身与 -errtags=yes 等效。<br/>
缺省情况下不显示标记 (-errtags=no)。<br/>
`demo% f95 -errtags ink.f`<br/>
`ink.f:`<br/>
`MAIN:`<br/>
`"ink.f", line 11: Warning: local variable "i" never used (WDECL_LOCAL_NOTUSED)`

- ## `–errwarn[={ %all|%none|taglist}]`

将警告消息视为错误。<br/>
taglist 指定应视为错误的警告消息对应的标记名称的逗号分隔列表。如果使用 %all，则将所有警告视为错误。如果使用 %none，则不将任何警告视为错误。<br/>
另请参见 -errtags。

- ## `–ext_names= e`

创建带有或不带尾随下划线的外部名称。<br/>
e 必须是 plain、underscores 或 fsecond-underscore。缺省为 underscores。<br/>
–ext_names=plain： 不增加结尾下划线。<br/>
–ext_names=underscores： 增加结尾下划线。<br/>
–ext_names=fsecond-underscore：在包含一个下划线的外部名称上附加两个下划线，在不包含下划线的外部名称上附加一个下划线。<br/>
外部名称是子例程、函数、块数据子程序或标记通用块的名称。此选项既影响例程入口点的名称，又影响调用例程时使用的名称。使用此标志可允许 Fortran 例程调用其他编程语言例程（以及被后者调用）。<br/>
提供 fsecond-underscore 是为了与 gfortran 兼容。

- ## `–F`

调用源文件预处理程序，但不进行编译。<br/>
将 fpp 预处理程序应用于命令行上列出的 .F、.F90、.F95 和 .F03<br/> 源文件，并将处理结果写入同名文件，但将该文件的扩展名更改为.f（或者是 .f95 或 .f03），不进行编译。<br/>
示例：<br/>
f95 -F source.F<br/>
将已处理的源文件写入 source.f<br/>
fpp 是 Fortran 的缺省预处理程序。通过指定 -xpp=cpp，可以改为选择 C 预处理程序 cpp。

- ## `–f`

对齐 COMMON 块中的双精度和四精度数据。<br/>
-f 是一个传统的选项标志，它与 -aligncommon=16 等效。首选使用 -aligncommon。<br/>
缺省情况下，按 4 字节边界对齐 COMMON 块中的数据。-f 将 COMMON 块和 EQUIVALENCE 类中双精度和四精度数据的数据布局更改为在内存中根据“自然”对齐方式（即，与 8 字节边界对齐）放置；如果在 64 位 SPARC 环境中使用 -m64 进行编译，则四精度数据与 16 字节边界对齐。<br/>
注 –<br/>
-f 可能导致数据以非标准方式对齐，从而使 EQUIVALENCE 或 COMMON 中的变量出现问题，并可能在需要 -f 的情况下使程序变为不可移植。<br/>
如果使用 -f 编译程序的任何部分，则要求使用 -f 编译该程序的所有子程序。<br/>
此选项本身并不允许编译器针对双精度和四精度数据生成速度更快的多字获取/存储指令。-dalign 选项执行此操作并调用 -f。相对于以前的-f，请优先使用 -dalign。请参见 –dalign。由于 -dalign 是 -fast 选项的一部分，因此 -f 也是它的一部分。

- ## `–f77[= list]`

选择 Fortran 77 兼容性模式。<br/>
此选项标志用于将传统的 Fortran 77 源程序（包括那些具有 f77 编译器可接受的语言扩展名的源程序）移植到 f95 Fortran 编译器。<br/>
list 是从下面可能的关键字中选择的逗号分隔列表：

![img](/img/in-post/2016-12-21-Fortran-compiler-options/25.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/26.png)

对于所有关键字，通过在前面加上 no% 可禁用相应功能，如下所示：<br/>
`-f77=%all,no%backslash`<br/>
如果未指定 -f77，则缺省为 -f77=%none。使用不带列表的 -f77 与指定 -f77=%all 是等效的。<br/>
异常捕获与 -f77：<br/>
指定 -f77 并不会更改 Fortran 捕获模式（即 -ftrap=common）。在运算异常捕获方面，f95 与 Fortran 77 编译器的行为不同。Fortran 77 编译器允许在出现运算异常之后继续执行。使用 -f77 进行编译还会使程序在退出时调用 ieee_retrospective，以报告可能出现的任何运算异常。在命令行上，在 -f77 选项标志之后指定 -ftrap=%none 可以模拟原来的 Fortran 77 行为。<br/>
有关f77 兼容性以及从 Fortran 77 迁移到 Fortran 95 的完整信息，请参见混合语言。<br/>
有关如何处理可能导致错误结果的非标准编程症状，另请参见 -xalias 标志。

- ## `–fast`

选择优化执行性能的选项。<br/>
注 –<br/>
该选项定义为其他选项的特殊选择集，它会随版本和编译器的不同而变化。另外，-fast 选择的某些选项并非在所有平台上都可用。使用 -dryrun 标志进行编译可查看 -fast 的扩展。<br/>
-fast 可为某些基准测试应用程序提供高性能。但是，对于您的应用程序，选项的特定选择可能是合适的，也可能是不合适的。使用 -fast 是编译应用程序以获得最佳性能的良好起点。但是，仍然可能需要进行其他调整。如果用 -fast 编译时程序不能正常运行，请仔细查看组成 -fast 的各个选项，只调用那些适用于您程序的选项，使程序正常运行。<br/>
另请注意，用 -fast 编译的程序对于一些数据集可能会表现出良好的性能和精确的结果，而对于另一些数据集则不然。对于那些依赖浮点运算的特殊属性的程序，请避免用 -fast 进行编译。<br/>
由于 -fast 选择的某些选项具有链接含义，因此，如果在不同的步骤中进行编译和链接，还请务必用 -fast 进行链接。<br/>
–fast 会选用以下选项：<br/>
-xtarget=native 硬件目标。 如果打算在编译计算机之外的其他目标计算机上运行程序，请在 -fast 之后加上代码生成器选项。例如：f95 -fast -xtarget=ultraT2 ...<br/>
-O5 优化级别选项。<br/>
-depend 选项分析循环以了解数据依赖性并重构循环（如有可能）。<br/>
-libmil 选项，用于系统提供的内联扩展模板。 对于依赖异常处理的 C 函数，请在 -fast 之后加上 -nolibmil（如 -fast -nolibmil）。如果使用了 -libmil，则使用 errno 或 matherr(3m) 无法检测到异常。<br/>
-fsimple=2 选项，用于主动浮点优化。如果要求严格遵循 IEEE 754 标准，则 –fsimple=2 是不合适的。请参见–fsimple[={ 1\|2\|0}]。<br/>
-dalign 选项可为通用块中的双精度和四精度数据生成双字装入和存储。使用此选项可以在通用块中生成非标准的 Fortran 数据对齐。<br/>
-xlibmopt 选项可选择优化的数学库例程。<br/>
-pad=local 可在局部变量之间插入填充（如果适用）以提高高速缓存利用率。(SPARC)<br/>
-xvector=lib 使用向量参数将 DO 循环内的某些数学库调用变换为对向量化库等效例程的单个调用。(SPARC)<br/>
–fns 可选择非标准浮点运算异常处理和渐进下溢。请参见–fns[ ={yes\| no}]。<br/>
选择 -fround=nearest，因为 —xvector 和 —xlibmopt 要求使用该选项。(Solaris)<br/>
-ftrap=common 用于捕获常见的浮点异常，在 f95 中处于启用状态。<br/>
-nofstore 对强制表达式具有结果精度这一行为加以取消。(x86)<br/>
-xregs=frameptr 允许编译器将帧指针寄存器用作未分配的被调用方保存寄存器。在 -fast 之后指定 -xregs=no%frameptr，帧指针寄存器将不会作为通用寄存器使用。(x86)<br/>
可以对此列表进行增减，方法是在 -fast 选项之后加上其他选项，如下所示：<br/>
f95 -fast -fsimple=1 -xnolibmopt ...<br/>
它会覆盖 -fsimple=2 选项，并禁用由 -fast 选择的 -xlibmopt。<br/>
由于 -fast 会调用 -dalign、-fns 和 -fsimple=2，因此用 -fast 编译的程序会导致非标准浮点运算、非标准数据对齐以及非标准表达式求值顺序。对于大多数程序来说，这些选择可能是不合适的。<br/>
请注意，由 -fast 标志选择的一组选项会随各个编译器发行版而发生变化。使用 -dryrun 调用编译器可显示 -fast 扩展：<br/>
`<sparc>%f95 -dryrun -fast |& grep ###`<br/>
`###     command line files and options (expanded):`<br/>
`### -dryrun -xO5 -xarch=sparcvis2 -xcache=64/32/4:1024/64/4`<br/>
`-xchip=ultra3i -xdepend=yes -xpad=local -xvector=lib`<br/>
`-dalign -fsimple=2 -fns=yes -ftrap=common -xlibmil`<br/>
`-xlibmopt -fround=nearest`

- ## `–fixed`

指定固定格式的 Fortran 95 源输入文件。<br/>
无论采用哪个文件扩展名，命令行上的所有源文件都将被解释为固定格式文件。通常，f95 仅将 .f 文件解释为固定格式文件，而将 .f95 解释为自由格式文件。

- ## `–flags`

与 -help 等效。

- ## `-fma={none|fused}`

(SPARC) 启用自动生成浮点乘加指令。-fma=none 禁用生成这些指令。-fma=fused 允许编译器通过使用浮点乘加指令尝试查找机会来提高代码性能。缺省值为 -fma=none。<br/>
编译器生成乘加指令的最低要求为 -xarch=sparcfmaf，优化级别至少为 -xO2。如果已生成乘加指令来避免在不支持它们的平台上执行程序，编译器将标记二进制程序。<br/>
乘加指令可以免除乘法和加法之间的中间舍入步骤。因此，如果使用 -fma=fused 编译，程序可能会生成不同的结果，但精度通常会增加而不是降低。

- ## `–fnonstd`

按非标准首选项初始化浮点硬件。<br/>
此选项是以下选项标志组合的宏：<br/>
`–fns -ftrap=common`<br/>
指定 -fnonstd 大致等效于 Fortran 主程序开始处的以下两个调用。<br/>
`i=ieee_handler("set", "common", SIGFPE_ABORT) `<br/>
`call nonstandard_arithmetic()`<br/>
nonstandard_arithmetic() 例程替代了早期发行版中已过时的 abrupt_underflow() 例程。<br/>
主程序必须使用此选项进行编译才能有效。<br/>
使用此选项初始化浮点硬件，以达到下列目的：<br/>
在出现浮点异常时终止（捕获）该异常。<br/>
如果下溢结果将提高速度，而不是生成 IEEE 标准所要求的次正规数，则将该结果刷新为零。<br/>
有关渐进下溢和次正规数的更多信息，请参见 -fns。<br/>
通过 -fnonstd 选项，可以针对浮点溢出、被零除和无效运算异常启用硬件陷阱。这些情况将转换为 SIGFPE 信号，而且如果程序没有 SIGFPE 处理程序，它将以转储内存而终止。<br/>
有关更多信息，请参见 ieee_handler(3m) 和 ieee_functions(3m) 手册页，以及《数值计算指南》和《Fortran 编程指南》。

- ## `–fns[ ={yes| no}]`

选择非标准浮点模式。<br/>
缺省值为标准浮点模式 (–fns=no)。（请参见《Fortran 编程指南》的“浮点运算”一章。）<br/>
可以选择使用 =yes 或 =no，提供了一种在包括 -fns 的其他宏标志（如 -fast）之后切换该标志的方式。-fns 不带值等同于 -fns=yes。<br/>
此选项标志在程序开始执行时启用非标准浮点模式。在 SPARC 平台上，指定非标准浮点模式会禁用“渐进下溢”，从而导致将微小的结果刷新为零，而不是生成次正规数。此外，还会导致次正规操作数在无提示的情况下替换为零。在那些不支持硬件中的渐进下溢和次正规数的 SPARC 系统上，使用此选项将显著提高某些程序的性能。<br/>
下表中的 x 不会导致总下溢，当且仅当 \|x\| 处于所示范围之一时，x 才是一个次正规数：<br/>
![img](/img/in-post/2016-12-21-Fortran-compiler-options/27.png)
有关次正规数的详细信息，请参见《数值计算指南》；有关此选项和类似选项的更多信息，请参见《Fortran 编程指南》的“浮点运算”一章。（一些算术家使用术语非正规数来代替次正规数。）<br/>
缺省情况下，对浮点首选项进行标准初始化：<br/>
IEEE 754 浮点运算是不停止的（即出现异常时不终止）。<br/>
下溢是渐进式的。<br/>
在 x86 平台上，此选项仅对 Pentium III 和 Pentium 4 处理器（sse 或 sse2 指令集）启用。<br/>
在 x86 上，-fns 选择 SSE 刷新为零模式以及非正规数为零模式（如果可用的话）。此标志导致将次正规结果刷新为零。如果可用的话，此标志还导致将次正规操作数视为零。此标志对使用 SSE 或 SSE2 指令集的传统 x87 浮点运算没有影响。<br/>
主程序必须使用此选项进行编译才能有效。

- ## `–fpover[={ yes|no}]`

检测格式化输入中的浮点溢出。<br/>
如果指定了 -fpover=yes ，则 I/O 库将检测格式化输入中的运行时浮点溢出并返回错误条件 (1031)。缺省情况下不进行此类溢出检测 (–fpover=no)。不带值的 -fpover 与 -fpover=yes 等效。同 —ftrap 组合使用可获得完整的诊断信息。

- ## `–fpp`

使用 fpp 强制对输入进行预处理。<br/>
通过 fpp 预处理程序传递在 f95 命令行上列出的所有输入源文件，而不管文件扩展名为何。（通常，fpp 仅自动预处理扩展名为.F、.F90 或 .F95 的文件。）另请参见–xpp={fpp\| cpp}。

- ## `–fprecision={single |double|extended}`

(x86) 初始化非缺省的浮点型舍入精度模式。<br/>
在 x86 上，将浮点精度模式设置为 single、double 或 extended。<br/>
如果值为 single 或 double，此标志会在程序启动时将舍入精度模式相应地设置为单精度或双精度。如果值为 extended,，或在缺省情况下且未指定 -fprecision 标志，则舍入精度模式将初始化为扩展精度。<br/>
此选项仅对 x86 系统且仅在编译主程序时使用才有效。

- ## `–free`

指定自由格式源输入文件。<br/>
命令行上的所有源文件都将被解释为 f95 自由格式源文件，而不管文件扩展名为何。通常，f95 仅将 .f 文件解释为固定格式文件，而将.f95 解释为自由格式文件。

- ## `–fround={nearest |tozero|negative| positive}`

设置启动时有效的 IEEE 舍入模式。<br/>
缺省值为 -fround=nearest。<br/>
主程序必须使用此选项进行编译才能有效。<br/>
可以由编译器在对常量表达式求值时使用。<br/>
是在程序初始化过程中在运行时建立的。<br/>
如果值为 tozero、negative 或 positive，该选项在程序开始执行时将舍入方向相应地设置为舍入为零、舍入为负无穷大或舍入为正无穷大。如果未指定 -fround，则将 -fround=nearest 用作缺省值，舍入方向是舍入为最接近的值。其含义与 ieee_flags 函数相同。（请参见《Fortran 编程指南》的“浮点运算”一章。）

- ## `–fsimple[={ 1|2|0}]`

选择浮点优化首选项。<br/>
允许优化器作出有关浮点运算的简化假定。（请参见《Fortran 编程指南》的“浮点运算”一章。）<br/>
为了获得一致的结果，请使用同一 -fsimple 选项编译程序的所有单元。<br/>
缺省值为：<br/>
如果不使用 -fsimple 标志，则编译器缺省为 -fsimple=0<br/>
如果使用不带值的 -fsimple，则编译器使用 -fsimple=1<br/>
各种浮点简化级别如下：<br/>
–fsimple=0<br/>
不允许简化假定。保持严格的 IEEE 754 一致性。<br/>
–fsimple=1<br/>
允许适度的简化。产生的代码与 IEEE 754 不完全一致，但多数程序所产生的数值结果没有更改。<br/>
在 -fsimple=1 的情况下，优化器可假定：<br/>
在进程初始化之后，IEEE 754 缺省舍入/捕获模式不发生改变。<br/>
可以删除不生成可见结果（潜在的浮点异常除外）的计算。<br/>
以无穷大或 NaN（“不是数”）为操作数的计算不需要将 NaN 传播到其结果；例如，x*0 可以由 0 替换。<br/>
计算过程不依赖于零的符号。<br/>
如果使用 -fsimple=1，则不允许优化器进行完全优化，而不考虑舍入或异常。特别是，在运行时舍入模式包含常量的情况下，浮点计算不能由产生不同结果的计算替换。<br/>
–fsimple=2<br/>
除 —fsimple=1 外，还允许主动浮点优化。这会导致某些程序因表达式求值方式的变化而生成不同的数值结果。尤其是，使用 -fsimple=2 可能会违反如下 Fortran 标准规则：要求编译器用显式圆括号将子表达式括起来以控制表达式求值顺序。对于依赖此规则的程序，这会导致数值舍入差异。<br/>
例如，如果使用 -fsimple=2，编译器可能将 C-(A-B) 计算为 (C-A)+B，从而违反了有关显式圆括号的标准规则（如果生成的代码已更好地进行了优化）。编译器还可能将 x/y 的重复计算替换为 x*z，其中的 z=1/y 计算一次并暂时保存，以消除成本较高的除法运算。<br/>
对于依赖浮点运算的特定属性的程序，不得使用 -fsimple=2 进行编译。<br/>
即使使用 -fsimple=2，也仍然不允许优化器在程序中引入浮点异常，如果不在这样的程序中引入浮点异常，该程序将不生成任何异常。
–fast 会选择 -fsimple=2。

- ## `–fstore`

(x86) 强制浮点表达式的精度。<br/>
对于赋值语句，此选项将所有浮点表达式强制为目标变量的精度。这是缺省值。但是，-fast 选项包括可用来禁用此选项的 -nofstore。-fast 后跟 -fstore 可以重新打开此选项。

- ## `–ftrap= t`

设置在启动时有效的浮点捕获模式。<br/>
t 是一个逗号分隔列表，它包含以下项中的一个或多个：<br/>
%all, %none, common , [no%]invalid , [no%]overflow , [no%]underflow , [no%]division ,[no%]inexact 。<br/>
-ftrap=common 是 -ftrap=invalid,overflow,division 的宏。<br/>
f95 的缺省值为 -ftrap=common。这与 C 和 C++ 编译器的缺省值不同，后者为 -ftrap=none。<br/>
设置在启动时有效的 IEEE 754 捕获模式，但不安装 SIGFPE 处理程序。可以使用 ieee_handler(3M) 或 fex_set_handling(3M) 启用陷阱并同时安装 SIGFPE 处理程序。如果指定多个值，则按从左到右顺序处理列表。按照定义，常见异常包括无效、被零除和溢出。<br/>
示例： -ftrap=%all,no%inexact 表示设置除 inexact 以外的所有陷阱。<br/>
-ftrap=t 的含义与 ieee_flags() 基本相同，不同之处是：<br/>
%all 打开所有捕获模式，并会导致捕获伪异常和预期异常。请改用 common。<br/>
%none 关闭所有捕获模式。<br/>
no% 前缀关闭该特定捕获模式。<br/>
主程序必须使用此选项进行编译才能有效。<br/>
有关详细信息，请参见《Fortran 编程指南》的“浮点运算”一章。

- ## `–G`

生成动态共享库，而不是生成可执行文件。<br/>
指示链接程序生成共享动态库。如果不使用 -G，则链接程序生成可执行文件。如果使用 -G，它将生成动态库。将 -o 与 -G 一起使用可以指定要写入的文件的名称。有关详细信息，请参见《Fortran 编程指南》的“库”一章。

- ## `–g`

针对调试和性能分析进行调试。<br/>
生成其他符号表信息，以便使用 dbx(1) 调试实用程序进行调试，并使用性能分析器进行性能分析。<br/>
虽然在不指定 -g 的情况下也可以进行一些调试，但是 dbx 和 debugger 的完整功能只供那些使用 -g 编译的编译单元使用。<br/>
与 -g 一起指定的其他选项的某些功能可能是有限的。有关详细信息，请参见 dbx 文档。<br/>
要使用性能分析器的完整功能，请使用 -g 进行编译。尽管一些性能分析功能不要求使用 -g，但是您必须使用 -g 进行编译才能查看带注释的源代码、一些函数级信息和编译器注释性消息。（请参见 analyzer(1) 手册页和《Sun Studio 性能分析器》手册。）<br/>
使用 -g 生成的注释性消息说明编译器在编译程序时进行的优化和变换。通过 er_src(1) 命令，可以显示与源代码交错的消息。<br/>
请注意，仅当编译器实际执行了优化时，才会出现注释性消息。如果请求高优化级别（如使用 -xO4 或 -fast），则更有可能看到注释性消息。

- ## `–hname`

指定已生成的动态共享库的名称。<br/>
此选项将被传递给链接程序。有关详细信息，请参见 Solaris《链接程序和库指南》以及《Fortran 编程指南》的“库”一章。<br/>
-hname 选项将名称 name 记录到共享动态库中，作为库的内部名称创建。-h 和 name 之间的空格是可选的（除非库名称是 elp，此时要求使用空格）。通常，name 必须与跟在 -o 后面的内容相同。如果不同时指定 -G，则使用此选项是无意义的。<br/>
如果不使用 -hname 选项，则在库文件中不记录内部名称。<br/>
如果库具有内部名称，则每当运行引用该库的可执行程序时，运行时链接程序将在其搜索的任何路径中搜索具有相同内部名称的库。在指定了内部名称的情况下，在运行时链接过程中搜索库更为灵活。此选项还可用于指定共享库的版本。<br/>
如果没有共享库的内部名称，则链接程序将改用共享库文件的特定路径。

- ## `–help`

显示编译器选项的摘要列表。<br/>
另请参见–xhelp={readme\| flags}。

- ## `–Ipath`

将 path 添加到 INCLUDE 文件搜索路径中。<br/>
在 INCLUDE 文件搜索路径的开始处插入目录路径 path。在 -I 和 path 之间不允许有空格。无效目录将被忽略，并且不显示警告消息。<br/>
include 文件搜索路径是在其中搜索 INCLUDE 文件（出现在预处理程序 #include 指令或 Fortran INCLUDE 语句中的文件名）的目录的列表。<br/>
示例： 在 /usr/app/include 中搜索 INCLUDE 文件：<br/>
`demo% f95 -I/usr/app/include growth.F`<br/>
在命令行上可以出现多个 -Ipath 选项。每个选项都添加到搜索路径列表的顶部（搜索的第一个路径）。<br/>
INCLUDE 或 #include 的相对路径的搜索顺序如下：<br/>
1.包含源文件的目录<br/>
2.在 -I 选项中指定的目录<br/>
3.编译器内部缺省列表中的目录<br/>
4./usr/include/<br/>
要调用预处理程序，您必须使用 .F、.F90、.F95 或 .F03 后缀来编译源文件。

- ## `-i8`

使用 —xtypemap=integer:64 指定该编译器的 8 字节 INTEGER。

- ## `–inline=[%auto][[ ,][no%]f1,…[ no%]fn]`

启用或禁用指定例程的内联。<br/>
请求优化器对出现在函数和子例程名称列表（用逗号分隔）中的用户编写例程进行内联。在例程名之前加上 no% 可禁用对该例程的内联。<br/>
内联是一种优化方法，编译器可以通过该方法有效地将子程序引用（如 CALL 或函数调用）替换为实际的子程序代码本身。内联通常为优化器提供更多生成高效代码的机会。<br/>
指定 %auto 可以在优化级别 -O4 或 -O5 上启用自动内联。如果使用 -inline 指定了显式内联，则这些优化级别的自动内联会正常关闭。<br/>
示例：对 xbar、zbar 和 vpoint 例程进行内联：<br/>
`demo% f95 -O3 -inline=xbar,zbar,vpoint *.f`<br/>
下面是一些限制；不发出任何警告：<br/>
必须在 -O3 或更高级别进行优化。<br/>
例程的源代码必须位于所编译的文件中，除非还指定了 -xipo 或 –xcrossfile。<br/>
编译器确定实际内联是否有利和安全。<br/>
-inline 与 -O4 一起使用可禁用编译器通常执行的自动内联，除非还指定了 %auto。如果使用 -O4，则编译器通常会尝试对用户编写的所有适当的子例程和函数进行内联。-inline 与 -O4 一起使用可能会降低性能，因为优化器只能对列表中的那些例程进行内联。在这种情况下，请使用 %auto 子选项启用 -O4 和 -O5 级别的自动内联。<br/>
`demo% f95 -O4 -inline=%auto,no%zpoint *.f`<br/>
在上例中，用户在禁止对编译器可能尝试的例程 zpoint() 进行任何可能的内联的同时，还启用了 -O4 级别的自动内联。

- ## `–iorounding[={ compatible|processor-defined}]`

为格式化输入/输出设置浮点舍入模式。<br/>
以全局方式为所有的格式化输入/输出运算设置 ROUND= 说明符。<br/>
如果使用 -iorounding=compatible，数据转换后的值是与两个最接近表示更接近的值，如果值正好在两者中间，则是离 0 远的值。<br/>
如果使用 -iorounding=processor-defined，则舍入模式是处理器的缺省模式。在未指定 -iorounding 时，这是缺省值。

- ## `–Kpic`

（已过时）与 -pic 等效。

- ## `–KPIC`

（已过时）与 -PIC 等效。

- ## `–Lpath`

将 path 添加到要在其中搜索库的目录路径的列表中。<br/>
将 path 添加到目标库搜索目录列表的前面。-L 和 path 之间的空格是可选的。此选项将传递给链接程序。另请参见–lx。<br/>
在生成可执行文件时，ld(1) 在 path 中搜索归档库（.a 文件）和共享库（.so 文件）。ld 在搜索缺省目录之前搜索 path。（有关库搜索顺序的信息，请参见《Fortran 编程指南》的“库”一章。）有关 LD_LIBRARY_PATH 和 -Lpath 之间的相对顺序，请参见 ld(1)。<br/>
注 –<br/>
使用 -L path 指定 /usr/lib 或 /usr/ccs/lib 可能会阻止链接未绑定的 libm。缺省情况下，将搜索这些目录。<br/>
示例： 使用 -Lpath 指定库搜索目录：
`demo% f95 -L./dir1 -L./dir2 any.f`

- ## `–lx`

将库 libx.a添加到链接程序的搜索库列表中。<br/>
将 -lx 传递给链接程序，以指定供 ld 在其中搜索未解析引用的其他库。ld 与对象库 libx 链接。如果共享库 libx.so 可用（且未指定 -Bstatic 或 -dn），则 ld 使用它，否则，ld 使用静态库 libx.a。如果它使用共享库，则将该名称生成到 a.out 中。在 -l和 x 字符串之间不允许有空格。<br/>
示例： 与库 libVZY 进行链接：<br/>
`demo% f95 any.f -lVZY`<br/>
再次使用 -lx 以便与更多的库链接。<br/>
示例： 与库 liby 和 libz 进行链接：<br/>
`demo% f95 any.f -ly -lz`<br/>
有关库搜索路径和搜索顺序的信息，另请参见《Fortran 编程指南》的“库”一章。

- ## `–libmil`

内联所选的用于优化的 libm 库例程。<br/>
某些 libm 库例程有内联模板。此选项会选择那些为当前使用的浮点选项和平台生成速度最快的可执行文件的内联模板。<br/>
有关更多信息，请参见 libm_single(3F) 和 libm_double(3F) 手册页。

- ## `–loopinfo`

显示循环的并行化结果。<br/>
显示哪些循环是使用 –autopar 选项并行化的以及哪些不是。<br/>
–loopinfo 显示有关标准错误的消息的列表：<br/>
`demo% f95 -c -fast -autopar -loopinfo shalow.f`<br/>
`...`<br/>
`"shalow.f", line 172: PARALLELIZED, and serial version generated`<br/>
`"shalow.f", line 173: not parallelized, not profitable`<br/>
`"shalow.f", line 181: PARALLELIZED, fused`<br/>
`"shalow.f", line 182: not parallelized, not profitable`<br/>
`...`<br/>
`...etc`

- ## `–Mpath`

指定 MODULE 目录、归档或文件。<br/>
在路径中查找当前编译中引用的 Fortran 模块。在当前目录之外的目录中搜索此路径。<br/>
path 可以指定目录、预编译模块文件的 .a 归档文件，或 .mod 预编译模块文件。编译器通过检查文件的内容来确定其类型。<br/>
要在其中搜索模块的 .a 归档文件必须在 -M 选项标志上显式指定。缺省情况下，编译器不搜索归档文件。<br/>
只搜索与出现在 USE 语句中的 MODULE 名称同名的 .mod 文件。例如，语句 USE ME 使编译器仅查找模块文件 me.mod。<br/>
搜索模块时，编译器为在其中写入模块文件的目录指定更高的优先级。这是由 -moddir 编译器选项或 MODDIR 环境变量控制的。如果上述两者都未指定，则缺省写入目录为当前目录。如果两者均已指定，则写入目录是 -moddir 标志指定的路径。<br/>
这意味着，如果只出现了 -M 标志，则先在当前目录中搜索模块，然后再在 -M 标志上列出的任何对象中进行搜索。要模拟以前发行版的行为，请使用：<br/>
`-moddir=empty-dir -Mdir -M`<br/>
其中 empty-dir 是空目录的路径。<br/>
-M 和路径之间可以有空格例如，-M /home/siri/PK15/Modules<br/>
在 Solaris 上，如果路径标识一个非归档文件或模块文件的常规文件，则编译器会将该选项传递给链接程序 ld，链接程序会将该选项作为链接程序映射文件。与 C 和 C++ 编译器类似，此功能作为公用选项提供。<br/>
有关 Fortran 中模块的更多信息，请参见模块文件。

- ## `–m32 | –m64`

为编译的二进制对象指定内存模型。<br/>
使用 -m32 创建 32 位可执行文件和共享库。使用 -m64 创建 64 位可执行文件和共享库。<br/>
在所有 Solaris 平台和不支持 64 位的 Linux 平台上，ILP32 内存模型（32 位 int、long、pointer 数据类型）是缺省值。在启用了 64 位的 Linux 平台上缺省为 LP64 内存模型（64 位 long 和指针数据类型）。-m64 仅允许在启用了 LP64 模型的平台上使用。<br/>
使用 -m32 编译的目标文件或库不能同使用 -m64 编译的目标文件或库链接。<br/>
当编译具有大量静态数据的应用程序时，可能还需要使用 -m64、-xmodel=medium。<br/>
请注意，部分 Linux 平台不支持中等模型。<br/>
注意，在以前的编译器发行版中，通过选择带有 -xarch 的指令集来实现内存模型 ILP32 或 LP64 。从 Sun Studio 12 编译器开始，就不再是这样了。在大多数平台上，仅需向命令行添加 -m64 即可创建 64 位对象。<br/>
在 Solaris 上，缺省为 -m32。在支持 64 位程序的 Linux 系统上，缺省为 -m64 -xarch=sse2。

- ## `–moddir= path`

指定编译器将写入已编译的 .mod MODULE 文件的位置。<br/>
编译器会将它编译的 .mod MODULE 信息文件写入由 path 指定的目录。也可以使用 MODDIR 环境变量指定目录路径。如果同时使用这两种方法指定了目录路径，则此选项标志优先。<br/>
编译器将当前目录用作写入 .mod 文件的缺省目录。<br/>
有关 Fortran 中模块的更多信息，请参见模块文件。

- ## `–mt`

要求链接到线程安全库。
如果您进行自己的低级线程管理（例如，通过调用 libthread 库），则使用 -mt 进行编译可防止冲突。<br/>
如果混合使用 Fortran 与调用 libthread 库的多线程 C 代码，请使用 -mt。另请参见 Solaris《多线程编程指南》。<br/>
在使用 -autopar 选项编译时自动使用 –mt。<br/>
请注意以下事项：<br/>
执行 I/O 的函数子程序本身不应该作为 I/O 语句的一部分被引用。在使用 -mt 时，这样的递归 I/O 可能会使程序出现死锁。<br/>
通常，不要使用 -autopar 编译自己的多线程代码。编译器生成的对线程库的调用可能与程序拥有的调用发生冲突，从而导致意外的结果。<br/>
在单处理器系统中，使用 -mt 选项可能会降低性能。

- ## `–native`

（已过时）优化主机系统的性能。<br/>
此选项与首选设置 -xtarget=native 等效。-fast 选项设置 -xtarget=native。

- ## `–noautopar`

禁用由先前出现在命令行上的 -autopar 调用的自动并行化。

- ## `–nodepend`

(SPARC) 取消先前出现在命令行上的任何 -depend。

- ## `-nofstore`

(x86) 取消命令行上的 -fstore。<br/>
编译器的缺省值为 -fstore。-fast 包括 -nofstore。

- ## `–nolib`

禁用与系统库的链接。<br/>
不自动与任何系统库或语言库链接；也就是说，不将任何缺省的 -lx 选项传递给 ld。正常行为是将系统库自动链接到可执行文件，而无需用户在命令行上指定它们。<br/>
使用 -nolib 选项，可以更轻松地静态链接其中的一个库。最终执行需要系统库和语言库。手动链接它们是您的责任。通过此选项，您可以完全控制与库的链接。<br/>
将 libm（静态）和 libc（动态）与 f95 链接：<br/>
`demo% f95 -nolib any.f95 -Bstatic -lm -Bdynamic -lc`<br/>
-lx 选项的顺序是很重要的。请遵循示例所示的顺序。

- ## `–nolibmil`

取消命令行上的 -libmil。<br/>
在 -fast 选项之后使用此选项，可禁用 libm 数学例程的内联：<br/>
`demo% f95 -fast -nolibmil …`

- ## `–noreduction`

禁用命令行上的 -reduction。<br/>
此选项禁用 -reduction。

- ## `–norunpath`

不会将运行时共享库搜索路径生成到可执行文件中。<br/>
编译器通常将一个路径生成到可执行文件中，从而告知运行时链接程序查找所需共享库的位置。该路径取决于具体的安装。-norunpath 选项阻止将该路径生成到可执行文件中。<br/>
如果已将库安装在一些非标准位置，而且您不希望在另一位置运行可执行文件时让加载器搜索这些路径，则此选项是很有用的。请与 -Rpaths 进行比较。<br/>
有关更多信息，请参见《Fortran 编程指南》的“库”一章。

- ## `–O[n]`

指定优化级别。<br/>
n 可以是 1、2、3、4 或 5。在 -O 和 n 之间不允许有空格。<br/>
如果未指定 -O[n]，则仅执行非常基本级别的优化，即限于局部公共子表达式消除和无用代码分析。与不使用优化相比，使用优化级别进行优化可以大大提高程序的性能。对于大多数程序，建议使用 -O（它设置 -O3）或 -fast（它设置 -O5）。<br/>
每个 -On 级别的优化都包括在低于它的级别上执行的优化。通常，编译程序时使用的优化级别越高，获得的运行时性能也越高。但是，优化级别越高，编译时间会越长，可执行文件也越大。<br/>
使用 -g 进行调试不会禁止 -On，但是 -On 在某些方面会限制 -g；请参见 dbx 文档。<br/>
-O3 和 -O4 选项降低调试的效用，这样您无法从 dbx 显示变量，但仍可以使用 dbx where 命令获取符号回扫。<br/>
如果优化器内存不足，则它尝试在较低优化级别上再次进行，即继续在原始级别上对后续例程进行编译。<br/>
有关优化的详细信息，请参见《Fortran 编程指南》的“性能剖析”和“性能与优化”这两章。

- ## `–O`

此选项与 -O3 等效。

- ## `–O1`

提供最少的语句级优化。<br/>
如果更高的级别会导致编译时间过长，或者超过了可用交换空间，请使用此选项。

- ## `–O2`

启用基本块级别的优化。<br/>
通常，此级别产生的代码大小是最小的。（另请参见 -xspace。）<br/>
–O3 的使用应优先于 -O2，除非 -O3 导致编译时间过长、超过交换空间或生成过大的可执行文件。

- ## `–O3`

在函数级别上增加循环解开和全局优化。自动添加 -depend。<br/>
通常，-O3 生成的可执行文件较大。

- ## `–O4`

增加包含在同一文件中的例程的自动内联。<br/>
通常，-O4 生成的可执行文件较大（因为进行了内联）。<br/>
-g 选项会禁止上述的 -O4 自动内联。–xcrossfile 可增加使用 -O4 情况下的内联范围。

- ## `–O5`

尝试主动优化。<br/>
仅适用于程序中占用计算时间最多的小段代码。-O5 的优化算法要花费更多的编译时间，而且在用于过大的源程序代码段时会降低性能。<br/>
如果使用分析反馈进行优化，则此级别上的优化更有可能提高性能。请参见 -xprofile=p。

- ## `–o name`

指定要写入的可执行文件的名称。<br/>
在 -o 和 name 之间必须有一个空格。 如果不设置此选项，则缺省设置是将可执行文件写入 a.out。在与 -c 一起使用时，-o 指定目标.o 目标文件；在与 -G 一起使用时，它指定目标 .so 库文件。

- ## `–onetrip`

启用单行程 DO 循环。<br/>
编译 DO 循环以便至少执行它们一次。如果上限小于下限，则在标准 Fortran 中根本不执行 DO 循环；这一点与 Fortran 的某些传统实现是不同的。

- ## `–openmp`

与 -xopenmp 等效。

- ## `–p`

（已过时）为使用 prof 配置程序进行分析而编译。<br/>
准备目标文件以进行分析，请参见 prof (1)。如果在不同的步骤中编译和链接，并且使用 -p 选项编译，请确保使用 -p 选项链接。将 -p 与prof 结合使用主要是为了与老系统兼容。使用 gprof 进行 -pg 分析可能是更好的方式。有关详细信息，请参见《Fortran 编程指南》的“性能剖析”一章。

- ## `–pad[= p]`

插入填充以便提高高速缓存的使用效率。<br/>
如果数组或字符变量是静态的局部数组或变量且未初始化，或者位于通用块中，则此选项在数组之间或字符变量之间插入填充。额外填充将数据定位以便更好地利用高速缓存。在任意一种情况下，数组或字符变量都不能是等效的。<br/>
如果 p 存在，则 p 必须为 %none，或者为 local 或 common 之一（或两者）：<br/>
![img](/img/in-post/2016-12-21-Fortran-compiler-options/28.png)
如果同时指定了 local 和 common，则它们可以以任意顺序显示。<br/>
-pad 的缺省值：<br/>
缺省情况下编译器不进行填充。<br/>
如果指定了 -pad 但不带值，则它与 -pad=local,common 等效。<br/>
-pad[=p] 选项适用于满足以下条件的项：<br/>
项是数组或字符变量<br/>
项是静态本地的或处于通用块中<br/>
有关本地或静态变量的定义，请参见–stackvar。<br/>
程序必须符合以下限制：<br/>
数组或字符串都不是等效的<br/>
如果为了对引用通用块的某个文件进行编译而指定了 -pad=common，则在对引用该通用块的所有文件进行编译时也必须指定它。此选项更改通用块内变量的间距。如果一个程序单元是使用该选项编译的，而另一个程序单元不是用该选项编译的，则在应该引用通用块中的同一位置时，可能会引用不同的位置。<br/>
如果指定了 -pad=common，不同程序单元中的通用块变量的声明除变量名称之外必须相同。通用块变量之间插入的填充量取决于这些变量的声明。如果变量在不同程序单元中的大小或等级不同，即使是在同一文件内，变量的位置也可能不同。<br/>
如果指定了 -pad=common，则用警告消息标记那些涉及通用块变量的 EQUIVALENCE 声明，而且不填充该块。<br/>
如果指定了 -pad=common，请避免通用块中出现索引超出数组边界的情况。如果更改已填充通用块中邻近数据的位置，将导致过度索引 (overindexing) 以不可预知的方式失败。<br/>
使用 -pad 时，程序员应确保以一致的方式编译通用块。如果不同程序单元中的通用块没有一致地使用 -pad=common 进行编译，则会导致错误。如果同名的通用块在不同的程序单元中具有不同的长度，则将报告正在使用 -Xlist 进行编译。

- ## `–pg`

为使用 gprof 配置程序进行分析而编译。<br/>
以 -p 的方式编译自配置代码，但调用一种运行时记录机制，该机制可保存更广泛的统计信息并在程序正常终止时生成 gmon.out 文件。通过运行 gprof 生成执行概要。有关详细信息，请参见 gprof(1) 手册页和《Fortran 编程指南》。<br/>
库选项必须跟在源文件和 .o 文件后面（–pg 库是静态的）。<br/>
注 –<br/>
如果指定了 -pg，则使用 -xprofile 进行编译并无优势。这两个功能中的任一功能不会准备或使用由另一个功能提供的数据。<br/>
使用 prof(1) 或 gprof(1)（在 64 位 Solaris 平台上）或者仅使用 gprof（在 32 位 Solaris 平台上）生成的配置文件中包括大致的用户 CPU 时间。这些时间来自主可执行文件中的例程以及共享库中例程（链接可执行文件时将共享库指定为链接程序参数）的 PC 示例数据（请参见pcsample(2)）。其他共享库（在进程启动后使用 dlopen(3DL) 打开的库）不进行分析。<br/>
在 32 位 Solaris 系统中，使用 prof(1) 生成的配置文件仅限于可执行文件中的例程。通过将可执行文件与 -pg 链接并使用 gprof(1)，可以对 32 位共享库进行分析。<br/>
Solaris 10 软件不包括使用 -p 编译的系统库。因此，在 Solaris 10 平台上收集的配置文件不包含系统库例程的调用计数。<br/>
不应当使用编译器选项 -p、-pg 或 -xpg 来编译多线程程序，因为这些选项的运行时支持不是线程安全的。如果利用这些选项来编译使用多个线程的程序，则可能会在运行时产生无效结果或段故障。<br/>
如果在不同的步骤中进行编译和链接，并使用 -pg 进行编译，请确保使用 -pg 进行链接。

- ## `–pic`

为共享库编译与位置无关的代码。<br/>
在 SPARC 上，–pic 与 -xcode=pic13 等效。有关与位置无关的代码的更多信息，请参见–xcode=keyword。<br/>
在 x86 上，生成与位置无关的代码。生成共享库时使用该选项编译源文件。对全局数据的每个引用都生成为全局偏移表中指针的非关联化。每个函数调用都通过过程链接表在 pc 相对地址模式中生成。

- ## `–PIC`

使用 32 位地址编译与位置无关的代码。<br/>
在 SPARC 上，–PIC 与 -xcode=pic32 等效。有关与位置无关的代码的更多信息，请参见–xcode=keyword。<br/>
在 x86 上，—PIC 与 —pic 等效。

- ## `–Qoption pr ls`

将子选项列表 ls 传递到编译阶段 pr。<br/>
必须使用空格来分隔 Qoption、pr 和 ls。Q 可以是大写的，也可以是小写的。该列表是一个逗号分隔的子选项列表，其中不包含空格。每个子选项都必须适合于该程序阶段，而且可以以负号开头。<br/>
提供此选项主要是为了供支持人员调试编译器的内部。使用 LD_OPTIONS 环境变量可以将选项传递给链接程序。请参见《Fortran 编程指南》中有关链接和库的章节。

- ## `–qp`

与 -p 等效。

- ## `–R ls`

将动态库搜索路径生成到可执行文件中。<br/>
如果使用此选项，则链接程序 ld(1) 将动态库搜索路径列表存储到可执行文件中。<br/>
ls 是一个用冒号分隔的库搜索路径目录列表。-R 和 ls 之间的空格是可选的。<br/>
此选项的多个实例并置在一起，各个列表由冒号分隔。<br/>
该列表由运行时链接程序 ld.so 在运行时使用。在运行时，将扫描所列出路径中的动态库以满足任何未解析的引用。<br/>
使用此选项，用户可以在不使用特殊路径选项查找所需动态库的情况下运行现有的可执行文件。<br/>
使用 -Rpaths 生成可执行文件，可将目录路径添加到缺省路径（始终最后搜索它）。<br/>
有关更多信息，请参见《Fortran 编程指南》的“库”一章以及 Solaris《链接程序和库指南》。

- ## `–r8const`

将单精度常量提升为 REAL*8 常量。<br/>
所有单精度 REAL 常量都将提升为 REAL*8 常量。双精度 (REAL*8) 常量保持不变。此选项仅适用于常数。要同时提升常量和变量，请参见–xtypemap= spec。<br/>
请小心使用此选项标志。当使用已提升为 REAL*8 常量的 REAL*4 常量调用需要 REAL*4 参数的子例程或函数时，此选项标志可能会导致接口问题。此选项标志还可能导致那些读取无格式数据文件的程序出现问题，这些文件是由无格式写入功能使用 I/O 列表上的 REAL*4 常量写入的。

- ## `-recl=a[,b]`

设置缺省输出记录长度。<br/>
为预连接单元输出（标准输出）和/或错误（标准错误）设置缺省记录长度（单位为字符）。此选项必须按下面的格式之一来指定：<br/>
-recl=out:N<br/>
-recl=error:N<br/>
—recl=out:N1 ,error:N2<br/>
-recl=error:N1 ,out:N2<br/>
-recl=all:N<br/>
其中，N、N1、N2 为 72 到 2147483646 之间的正整数值。out 指标准输出，error 指标准错误，all 为这两者设置缺省记录长度。缺省为 -recl=all:80。仅在当前编译的程序有 Fortran 主程序时，此选项才有效。

- ## `–reduction`

识别循环中的约简操作。<br/>
在自动并行化期间分析循环以了解约简操作。约简操作可能存在舍入误差。<br/>
约简操作将数组元素累加为单个标量值。例如，对向量元素求和是典型的约简操作。虽然这些操作违反了可并行化标准，但是编译器可以识别它们，并在指定了 -reduction 时作为特殊情况对它们进行并行化。有关编译器可识别的约简操作的信息，请参见《Fortran 编程指南》的“并行化”一章。<br/>
此选项只能与自动并行化选项 —autopar 一起使用。否则，它将被忽略。对于约简操作，不分析显式并行化的循环。

- ## `–S`

编译并仅生成汇编代码。<br/>
编译指定的程序，并在后缀为 .s 的相应文件中保留汇编语言输出，而不创建 .o 文件。

- ## `–s`

将符号表与可执行文件分离。<br/>
此选项使可执行文件变得更小，并使逆向工程的实施更困难。但是，此选项禁止使用 dbx 或其他工具进行调试，而且覆盖 -g。

- ## `–sb`

（已过时－忽略此选项。）

- ## `–sbfast`

（已过时－忽略此选项。）

- ## `–silent`

（已过时）禁止显示编译器消息。<br/>
通常，f95 编译器在编译过程中不发出除错误诊断之外的消息。提供此选项标志是为了与传统的 f77 编译器兼容；除非与 -f77 兼容性标志一起使用，否则使用它是多余的。

- ## `–stackvar`

尽可能在栈上分配局部变量。<br/>
此选项使编写递归代码和可重入代码更容易，并在并行化循环时为优化器提供更多自由。<br/>
建议将 -stackvar 与任何并行化选项一起使用。<br/>
局部变量是除哑元参数、COMMON 变量、从外部作用域继承的变量或可通过 USE 语句访问的模块变量之外的变量。<br/>
在 -stackvar 有效的情况下，局部变量是在栈上分配的，除非它们具有属性 SAVE 或 STATIC。请注意，显式初始化的变量是使用 SAVE属性隐式声明的。缺省情况下，未显式初始化但其某些组件已初始化的结构变量，没有使用 SAVE 隐式声明。此外，与具有 SAVE 或 STATIC属性的变量等效的变量，也隐式具有 SAVE 或 STATIC。<br/>
以静态方式分配的变量隐式初始化为零，除非程序为其显式指定了初始值。在栈上分配的变量并未隐式初始化（缺省情况下可进行初始化的结构变量的组件除外）。<br/>
使用 -stackvar 将大数组放在栈上可以使栈溢出，从而导致段故障。此时可能需要增加栈大小。<br/>
执行程序的初始线程有一个主栈，而多线程程序的每个辅助线程都有自己的线程栈。<br/>
主栈的缺省大小约为 8 兆字节。线程栈在 32 位系统上缺省大小为 4 兆字节，在 64 位系统上缺省大小为 8 兆字节。limit 命令（不带参数）可显示当前的主栈大小。如果使用 -stackvar 时出现段故障，请尝试增加主栈和线程栈的大小。<br/>
示例： 显示当前的主栈大小：<br/>
`demo% limit`<br/>
`cputime         unlimited`<br/>
`filesize        unlimited`<br/>
`datasize        523256 kbytes`<br/>
`stacksize       8192 kbytes      <–––`<br/>
`coredumpsize    unlimited`<br/>
`descriptors     64`<br/>
`memorysize      unlimited`<br/>
`demo%`<br/>
示例： 将主栈大小设置为 64 兆字节：<br/>
`demo% limit stacksize 65536`<br/>
示例： 将每个线程栈大小设置为 8 兆字节：<br/>
`demo% setenv STACKSIZE 8192`<br/>
通过为 STACKSIZE 环境变量指定值（单位为千字节），可以设置每个从线程使用的栈大小：<br/>
`% setenv STACKSIZE 8192`<br/>
将每个从线程的栈大小设置为 8 MB。<br/>
STACKSIZE 环境变量还接受带有 B（字节）、K（千字节）、M（兆字节）或 G（千兆字节）后缀的数值。缺省单位为千字节。<br/>
请注意，STACKSIZE 环境变量仅影响使用 —xopenmp 或 —xautopar 选项编译的程序，而不会影响 Solaris 系统上使用 pthreads 接口的程序。<br/>
有关与并行化一起使用 -stackvar 的详细信息，请参见《Fortran 编程指南》的“并行化”一章。有关 limit 命令的详细信息，请参见csh(1)。<br/>
使用 -xcheck=stkovf 进行编译，可启用栈溢出情况的运行时检查。请参见–xcheck=keyword。

- ## `–stop_status[={ yes|no}]`

允许 STOP 语句返回整数状态值。<br/>
缺省值为 -stop_status=no。<br/>
如果使用 -stop_status=yes，则 STOP 语句可以包含整型常量。在程序终止时，该值将传递到环境：<br/>
STOP 123<br/>
该值的范围必须介于 0 到 255 之间。大于这个范围的值将被截断，并且会发出运行时消息。请注意，尽管将发出编译器警告消息，但是仍将接受<br/>
STOP "stop string"<br/>
并将状态值 0 返回到环境。<br/>
环境状态变量是 $status（对于 C shell csh）和 $?（对于 Bourne shell sh 和 Korn shell ksh）。

- ## `–temp=dir`

为临时文件定义目录。<br/>
将编译器所用临时文件的目录设置为 dir。在此选项字符串中不允许有空格。如果不使用此选项，则将这些文件放在 /tmp 目录中。<br/>
此选项优先于 TMPDIR 环境变量的值。

- ## `–time`

每个编译阶段所用时间。<br/>
将显示每次编译过程所用的时间和资源。

- ## `–U`

识别源文件中的大写字母和小写字母。<br/>
不将大写字母视为与小写字母等效。缺省情况下，将大写字母视为小写字母（字符串常量中的字母除外）。如果使用此选项，编译器会将Delta、DELTA 和 delta 视为不同的符号。此选项不会影响对内部函数的调用。<br/><br/>
可移植性以及将 Fortran 与其他语言混合使用可能要求使用 -U。请参见《Fortran 编程指南》中有关将程序移植到 Sun Studio Fortran 的一章。

- ## `-Uname`

取消预处理程序宏 name 的定义。<br/>
此选项仅适用于那些调用 fpp 或 cpp 预处理程序的源文件。它会删除同一命令行上由 -Dname 创建的预处理程序宏 name 的任何初始定义（包括由命令行驱动程序隐式放在此处的那些内容）而不管选项出现的顺序如何。它对源文件中的任何宏定义都没有影响。在命令行上可以出现多个-Uname 标志。-U 和宏 name 之间不得有空格。

- ## `–u`

报告未声明的变量。<br/>
使所有变量的缺省类型都成为未声明的，而不是使用 Fortran 隐式确定类型，就好像 IMPLICIT NONE 出现在每个编译单元中一样。此选项警告存在未声明的变量，并且不覆盖任何 IMPLICIT 语句或显式 type 语句。

- ## `–unroll=n`

启用 DO 循环的解开（如果可能）。<br/>
n 是正整数。选项有：<br/>
n=1 禁止解开所有循环。<br/>
n>1 建议优化器尝试解开循环 n 次。<br/>
通常，解开循环可提高性能，但会增加可执行文件的大小。有关此编译器及其他编译器优化的更多信息，请参见《Fortran 编程指南》的“性能与优化”一章。另请参见UNROLL 指令。

- ## `–use= list`

指定隐式 USE 模块。<br/>
list 是模块名称或模块文件名称的逗号分隔列表。<br/>
使用 -use=module_name 进行编译，可将 USE module_name 语句添加到正在编译的每个子程序或模块中。使用 -use=module_file_name进行编译，可为包含在指定文件中的每个模块添加 USE module_name。<br/>
有关 Fortran 中模块的更多信息，请参见模块文件。

- ## `–V`

显示每次编译过程的名称和版本。<br/>
此选项在编译器执行时打印每个工作循环的名称和版本。<br/>
在与 Sun 服务工程师讨论问题时，此信息可能非常有用。

- ## `–v`

详细模式－显示每次编译过程的详细信息。<br/>
与 -V 一样，此选项在编译器执行时显示每个工作循环的名称，以及驱动程序使用的选项、宏标志扩展和环境变量的详细信息。

- ## `-vax=keywords`

指定所启用的 VAX VMS Fortran 扩展选项。<br/>
keywords 说明符必须是以下子选项之一或从中选择的子选项的逗号分隔列表。
![img](/img/in-post/2016-12-21-Fortran-compiler-options/29.png)
通过在子选项前面加上 no%，可以单独选择或关闭该子选项。<br/>
示例：<br/>
`-vax=debug,rsize,no%blank_zero`

- ## `–vpara`

显示详细的并行化消息。<br/>
在编译器对那些用指令显式标记为并行化的循环进行分析时，它发出有关所检测到的某些数据依赖性的警告消息；但是仍将对循环进行并行化。<br/>
与 -xopenmp 和 OpenMP API 指令结合使用。<br/>
由编译器发出的警告检测到下列情形：<br/>
OpenMP 数据共享属性子句使用不当。例如，将变量声明为共享，而在 OpenMP 并行区域中访问该变量会导致数据争用；或者将变量声明为私有，但在并行区域后面使用其在并行区域中的值。<br/>
如果在处理所有并行化指令时没有出现任何问题，则不显示警告。<br/>
注 –<br/>
Sun Studio 编译器支持 OpenMP API 并行化模型。因此，传统的 C$MIC 并行化指令已过时，将被忽略。有关迁移到 OpenMP API 的信息，请参见《OpenMP API 用户指南》。

- ## `–w[n]`

显示或禁止警告消息。<br/>
此选项显示或禁止大多数警告消息。但是，如果一个选项覆盖命令行上先前选项的全部或部分，您确实会收到一条警告消息。<br/>
n 可以是 0、1、2、3 或 4。<br/>
-w0 仅显示错误消息。它等效于 -w。-w1 显示错误和警告。这是不带 -w 情况下的缺省设置。-w2 显示错误、警告和注意。-w3 显示错误、警告、注意和说明。-w4 显示错误、警告、注意、说明和注释。

- ## `–Xlist[ x]`

（仅限 Solaris）生成列表并进行全局程序检查 (global program checking, GPC)。<br/>
使用此选项可查找潜在的编程错误。它调用额外的编译过程，以便在全局程序中检查子程序调用参数、通用块和参数的一致性。此选项还生成带行号的源代码列表，包括交叉引用表。由 -Xlist 选项发出的错误消息是建议性警告，不会阻止程序的编译和链接。<br/>
注 –<br/>
请确保在使用 -Xlist 进行编译之前，更正源代码中的所有语法错误。如果运行有语法错误的源代码，可能会产生不可预知的报告。<br/>
示例： 检查例程之间的一致性：<br/>
`demo% f95 -Xlist  fil.f`<br/>
上述示例将以下内容写入输出文件 fil.lst：<br/>
带行号的源代码列表（缺省）<br/>
有关例程间不一致性的错误消息（嵌入在列表中）<br/>
标识符的交叉引用表（缺省）<br/>
缺省情况下，将列表写入文件 name.lst，其中 name 采用命令行上列出的第一个源文件。<br/>
许多子选项为操作选择提供了更多灵活性。它们是由 -Xlist 主选项的后缀指定的，如下表所示：
![img](/img/in-post/2016-12-21-Fortran-compiler-options/30.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/31.png)
有关详细信息，请参见《Fortran 编程指南》的“程序分析和调试”一章。<br/>
此选项在 Linux 系统上不可用。

- ## `–xa`

与 -a 等效。

- ## `-xaddr32[={ yes|no}]`

（仅限 x86/x64）-xaddr32=yes 编译标志将所生成的可执行文件或共享对象限制在 32 位地址空间。<br/>
按此方式编译的可执行文件会导致创建一个限制在 32 位地址空间的进程。如果指定了 -xaddr32=no，则会生成通常的 64 位二进制文件。如果未指定 -xaddr32 选项，则使用 -xaddr32=no。如果仅指定了 -xaddr32，则使用 -xaddr32=yes。<br/>
此选项仅适用于支持 SF1_SUNW_ADDR32 软件功能的 Solaris 平台的 -m64 编译。由于 Linux 内核不支持地址空间限制，此选项在 Linux 上不可用。在 Linux 上将忽略 -xaddr32 选项。<br/>
在链接时，如果有一个目标文件是使用 -xaddr32=yes 编译的，则整个输出文件均缺省使用 -xaddr32=yes 进行编译。限制到 32 位地址空间的共享对象必须由在受限的 32 位模式地址空间内执行的进程来加载。有关详细信息，请参阅《链接程序和库指南》中的 SF1_SUNW_ADDR32 软件功能定义。

- ## `–xalias[= keywords]`

指定要由编译器假定的别名程度。<br/>
一些非标准编程方法会产生干扰编译器优化策略的情况。使用过度索引、指针以及将全局或非唯一变量作为子程序参数进行传递，会产生歧义别名情况，从而使代码无法按预期方式运行。<br/>
使用 -xalias 标志可将程序偏离 Fortran 标准的别名要求的程度通知给编译器。<br/>
此标志可能带有关键字列表，也可能不带关键字列表。keywords 列表由逗号分隔，各个关键字指示程序中存在的别名情况。<br/>
可以在每个关键字前面加上 no%，以指示不存在的别名类型。<br/>
别名关键字如下：
![img](/img/in-post/2016-12-21-Fortran-compiler-options/32.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/33.png)
指定不带列表的 -xalias 将为不违反 Fortran 别名规则的大多数程序提供最佳性能，不带列表的 -xalias 等效于：<br/>
no%dummy,no%craypointer,no%actual,no%overindex,no%ftnpointer<br/>
为了提高效率，在使用优化级别 -xO3 及更高级别进行编译时，应该使用 -xalias。<br/>
如果未指定 -xalias 标志，则编译器在缺省情况下假定程序符合 Fortran 标准（Cray 指针除外）：<br/>
no%dummy,craypointer,no%actual,no%overindex,no%ftnpointer<br/>
有关各种别名情况的示例以及如何使用 -xalias 指定它们，请参见《Fortran 编程指南》的“移植”一章。

- ## `-xannotate[={ yes|no}]`

（仅限 Solaris）指示编译器创建稍后可用 binopt(1) 等二进制修改工具进行转换的二进制文件。<br/>
深入二进制分析、代码覆盖和内存错误检测工具也可以处理使用此选项生成的二进制文件。<br/>
使用 -xannotate=no 选项可以防止这些工具修改二进制文件。-xannotate=yes 选项必须与 -xO1 或更高优化级别结合使用才能有效，而且它只在包含新链接程序支持库接口 - ld_open() 的系统上有效。如果在不包含此链接程序接口的系统（如 Solaris 9 和 Solaris 10 的早期版本）上使用编译器，则该选项会转换为 -xannotate=no 而不发出任何提示。<br/>
缺省值为 -xannotate=yes，但如果不满足上述两种情况，则缺省转换为 -xannotate=no。<br/>
此选项在 Linux 系统上不可用。

- ## `–xarch=isa`

指定指令集体系结构 (instruction set architecture, ISA)。<br/>
-xarch 关键字 isa 接受的体系结构如表所示：
![img](/img/in-post/2016-12-21-Fortran-compiler-options/34.png)
请注意，尽管 -xarch 可以单独使用，但它是 –xtarget 选项扩展的一部分，并且可用于覆盖由特定 -xtarget 选项设置的 -xarch 值。例如：<br/>
% f95 -xtarget=ultra2 -xarch=sparcfmaf ...<br/>
会覆盖由 -xtarget=ultra2 设置的 -xarch。<br/>
通过只允许指定的指令集，此选项可将编译器生成的代码限定于指定指令集体系结构的指令。此选项不保证使用任何特定于目标的指令。<br/>
如果此选项与优化一起使用，则在指定的体系结构上，适当的选择可以为可执行文件提供良好性能。如果选择不当，则会导致二进制程序在预定的目标平台上无法执行。<br/>
请注意以下事项：<br/>
传统的 32 位 SPARC 指令集体系结构 V7 和 V8 指 —m32，并且无法与 —m64 组合。<br/>
可以链接使用 sparc 和 sparcvis 编译的目标二进制文件 (.o)，并可同时执行它们，但只能在 sparcvis 兼容的平台上运行。<br/>
可以链接使用 sparc、sparcvis 和 sparcvis2 编译的目标二进制文件 (.o)，并可同时执行它们，但只能在 sparcvis2 兼容的平台上运行。<br/>
对于任何特定选择，生成的可执行文件在早期体系结构中运行时都会慢得多。此外，虽然在多数指令集体系结构中都可以使用四精度（REAL*16和 long double）浮点指令，但编译器不在它生成的代码中使用这些指令。<br/>
未指定 -xarch 选项时的缺省值为 generic。<br/>
下表提供了有关 SPARC 平台上每个 -xarch 关键字的详细信息
![img](/img/in-post/2016-12-21-Fortran-compiler-options/35.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/36.png)
下表详细介绍了 x86 平台上的每个 -xarch 关键字。如果未指定 -xarch，x86 上的缺省值为 generic（或者如果指定了 —m64 则为generic64）。
![img](/img/in-post/2016-12-21-Fortran-compiler-options/37.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/38.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/39.png)

- ## `x86/x64 平台的特别注意事项`

当针对 x86 Solaris 平台进行编译时，有几项重要的注意事项。<br/>
使用设置为 sse、sse2、sse2a 或 sse3 等的 -xarch 编译的程序必须在支持这些功能和扩展的平台上运行。<br/>
从 Solaris 9 4/04 开始的操作系统发行版在 Pentium 4 兼容的平台上支持 SSE/SSE2。早期版本的 Solaris OS 不支持 SSE/SSE2。<br/>
如果在不同的步骤中进行编译和链接，请始终使用编译器和相同的 -xarch 设置进行链接，以确保链接正确的启动例程。<br/>
x86 上的运算结果可能与 SPARC 上的结果不同，这是由 x86 80 字节浮点寄存器造成的。为了最大限度减少这些差异，请使用 -fstore 选项或使用 -xarch=sse2 进行编译（如果硬件支持 SSE2）。<br/>
从 Sun Studio 11 和 Solaris 10 操作系统开始，会对使用这些专用的 -xarch 硬件标志编译和生成的程序二进制文件进行验证，看其是否在适当的平台上运行。<br/>
在 Solaris 10 以前的系统上，不进行任何验证，而是由用户负责确保使用这些标志生成的对象已部署在适当的硬件上。<br/>
如果在没有相应功能或指令集扩展的平台上运行使用这些 -xarch 选项编译的程序，则可能会导致段故障或不正确的结果，并且不显示任何显式警告消息。<br/>
此警告还会扩展到采用 .il 内联汇编语言函数或 __asm() 汇编程序代码（使用 SSE、SSE2、SSE2a 和 SSE3 指令和扩展）的程序。

- ## `–xassume_control[ =keywords]`

设置参数以控制 ASSUME pragma。<br/>
使用此标志可控制编译器处理源代码中 ASSUME pragma 的方式。<br/>
ASSUME pragma 为程序员提供了一种断言特殊信息（编译器使用这些特殊信息实现较佳的优化）的方法。可以使用可能值限定这些断言。可能值为 0 或 1 的断言将被标记为“确定”，否则视为不确定。<br/>
也可以使用可能性或确定性来断言将要执行的 DO 循环的行程计数，或断言将要采取的分支。<br/>
有关 f95 编译器可识别的 ASSUME pragma 的说明，请参见ASSUME 指令。<br/>
-xassume_control 选项上的 keywords 可以是一个子选项关键字，也可以是关键字的逗号分隔列表。可以识别的关键字子选项如下：
![img](/img/in-post/2016-12-21-Fortran-compiler-options/40.png)
编译器的缺省值是<br/>
-xassume_control=optimize<br/>
这意味着，编译器可识别 ASSUME pragma，而且后者将影响优化，但不进行检查。<br/>
如果指定不带参数的 -xassume_control，则隐含<br/>
-xassume_control=check,fatal<br/>
在这种情况下，编译器接受并检查所有确定的 ASSUME pragma，但是后者不影响优化。无效的断言将导致程序终止。

- ## `–xautopar`

与 -autopar 等效。

- ## `–xbinopt={prepare | off}`

(SPARC) 准备二进制文件以进行编译后优化。<br/>
binopt(1) 将启用已编译的二进制文件，供以后进行优化、变换和分析使用。在生成可执行文件或共享对象时可以使用此选项，但是它必须与 -O1 或更高优化级别一起使用才有效。<br/>
在使用此选项生成时，二进制文件的大小会有所增加，大约增加 5%。<br/>
如果在不同的步骤中进行编译和链接，则 -xbinopt 必须既出现在编译步骤中，也出现在链接步骤中。<br/>
如果应用程序的源代码并不都是使用 -xbinopt 编译的，则 -xbinopt 标志仍应当出现在用于生成程序二进制文件的最终链接步骤中，如下所示：<br/>
example% f95 -0 program -xbinopt=prepare a.o b.o c.f95<br/>
只有使用 -xbinopt 编译的代码才能用 binopt(1) 优化。<br/>
缺省值为 -xbinopt=off。

- ## `–xcache=c`

为优化器定义高速缓存属性。<br/>
c 必须是以下值之一：<br/>
generic<br/>
native<br/>
s1/ l1/a1[/t1]<br/>
s1/ l1/a1[/t1] :s2/l2 /a2[/t2]<br/>
s1/ l1/a1[/t1] :s2/l2 /a2[/t2] :s3/l3 /a3[/t3]<br/>
si/li /ai/ti 的定义如下：<br/>
si 是 i 级数据高速缓存的大小（千字节）；li 是 i 级数据高速缓存的行大小（字节）；ai 是 i 级数据高速缓存的关联性；ti 是共享 i 级高速缓存的硬件线程数（可选）。<br/>
该选项指定了优化器可以使用的缓存属性，不保证使用每个特定的缓存属性。<br/>
尽管此选项可以单独使用，但它是 –xtarget 选项扩展的一部分；提供它是为了允许覆盖特定 -xtarget 选项所隐含的 -xcache 值。
![img](/img/in-post/2016-12-21-Fortran-compiler-options/41.png)
示例： -xcache=16/32/4:1024/32/1 指定以下内容：<br/>
一个 1 级高速缓存具有以下属性：16K 字节、32 字节行大小、4 路关联性。<br/>
一个 2 级高速缓存具有以下属性： 1024K 字节、32 字节行大小、直接映射关联性。

- ## `–xcheck=keyword`

生成特殊的运行时检查和初始化。<br/>
keyword 必须是以下项之一：
![img](/img/in-post/2016-12-21-Fortran-compiler-options/42.png)
栈溢出（尤其是在栈上分配大数组的多线程应用程序中）可能会在邻近线程栈中导致无提示的数据损坏。如果怀疑存在栈溢出，请使用 -xcheck=stkovf 编译所有例程。但请注意，使用此标志进行编译不保证将检测到所有栈溢出情况，因为它们可能出现在不是使用此标志编译的例程中。

- ## `–xchip=c`

为优化器指定目标处理器。<br/>
此选项通过指定目标处理器来指定计时属性。<br/>
尽管此选项可以单独使用，但它是 –xtarget 选项扩展的一部分；提供它是为了允许覆盖特定 -xtarget 选项所隐含的 -xchip 值。<br/>
下面是 -xchip=c 的一些作用：<br/>
指令调度<br/>
编译分支的方式<br/>
在语义等效的两个选择项之间进行选择<br/>
下面的两个表列出了有效的 -xchip 处理器名称值：<br/>
常用的 –xchip SPARC 处理器的名称
![img](/img/in-post/2016-12-21-Fortran-compiler-options/43.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/44.png)
在 x86 平台上：-xchip 值为 pentium、pentium_pro、pentium3、pentium4、generic、opteron、core2、penryn、nehalem、amdfam10 和 native。

- ## `–xcode=keyword`

(SPARC) 指定 SPARC 平台上的代码地址空间。<br/>
keyword 的值包括：
![img](/img/in-post/2016-12-21-Fortran-compiler-options/45.png)
如果不显式指定 -xcode=keyword，则缺省值是：<br/>
–xcode=abs32（32 位平台）；–xcode=abs44（64 位平台）。<br/>
与位置无关的代码：<br/>
在创建动态共享库以提高运行时性能时，可使用 -xcode=pic13 或 -xcode=pic32。<br/>
虽然动态可执行文件内的代码通常绑定到内存中的固定地址，但是可以将与位置无关的代码装入进程地址空间中的任意位置。<br/>
在使用与位置无关的代码时，将生成可重定位引用，作为通过全局偏移表的间接引用。在使用 -xcode=pic13 或 -xcode=pic32 进行编译时，由于不要求大量的重定位（这些重定位是与位置有关的代码所强制的），因此会使共享对象中的频繁访问项获益。<br/>
全局偏移表的大小不应超过 8Kb。<br/>
-xcode={pic13\|pic32} 有两个名义性能成本：<br/>
使用 -xcode=pic13 或 -xcode=pic32 编译的例程在入口处执行几个额外的指令，以便将寄存器设置为指向用于访问共享库的全局变量或静态变量的全局偏移表。<br/>
每次访问全局变量或静态变量时，都会涉及到通过全局偏移表进行额外的间接内存引用。如果编译是使用 pic32 进行的，则每个全局和静态内存引用都有两个额外指令。<br/>
在考虑上述成本时，请记住：由于受到库代码共享的影响，使用 -xcode=pic13 或 -xcode=pic32 会大大减少系统内存需求。共享库中已使用 -xcode=pic13 或 -xcode=pic32 编译的每个代码页，都可以由使用该库的每个进程共享。如果共享库中的代码页包含非 pic（即绝对）内存引用，即使仅包含单个非 pic 内存引用，该页也将变为不可共享，而且每次执行使用该库的程序时都必须创建该页的副本。<br/>
确定是否已使用 -xcode=pic13 或 -xcode=pic32 编译 .o 文件的最简单方法是使用 nm 命令：<br/>
nm file.o \| grep _GLOBAL_OFFSET_TABLE_<br/>
包含与位置无关的代码的 .o 文件将包含对 _GLOBAL_OFFSET_TABLE_ 的未解析外部引用（用字母 U 标记）。<br/>
要确定是使用 -xcode=pic13 还是 -xcode=pic32，请通过使用 elfdump -c（有关更多信息，请参见 elfdump(1) 手册页）来查看全局偏移表 (Global Offset Table, GOT) 的大小以及节标题 sh_name: .got。sh_size 值是 GOT 的大小。如果 GOT 小于 8,192 字节，请指定-xcode=pic13，否则指定 -xcode=pic32。<br/>
通常，应根据以下准则来确定如何使用 -xcode：<br/>
如果要生成可执行文件，则不应该使用 -xcode=pic13 或 -xcode=pic32。<br/>
如果是生成仅用于链接到可执行文件的归档库，则不应该使用 -xcode=pic13 或 -xcode=pic32。<br/>
如果要生成共享库，请先使用 -xcode=pic13，一旦 GOT 大小超过 8,192 字节，则使用 -xcode=pic32。<br/>
如果要生成用于链接到共享库的归档库，则应该使用 -xcode=pic32。<br/>
在生成动态库时，建议使用 -xcode=pic13 或 pic32（或者 -pic 或 -PIC）选项进行编译。请参见 Solaris《链接程序和库指南》。

- ## `–xcommonchk[={ yes|no}]`

启用通用块不一致性的运行时检查。<br/>
此选项提供了检测使用 TASK COMMON 及并行化的程序中的通用块不一致性的调试检查。（请参见《Fortran 编程指南》的“并行化”一章中有关TASK COMMON 指令的讨论。）<br/>
缺省值为 -xcommonchk=no；即，用于检测通用块不一致性的运行时检查处于禁用状态，因为它会导致性能降低。请仅在程序开发和调试过程中使用 -xcommonchk=yes，而不应将其用于符合最终产品质量的程序。<br/>
使用 -xcommonchk=yes 进行编译会启用运行时检查。如果在一个源程序单元中声明为正规通用块的通用块出现在 TASK COMMON 指令上的某个其他位置，则程序将停止并显示一条错误消息，指出第一个此类不一致。不带值的 -xcommonchk 与 -xcommonchk=yes 等效。<br/>

- ## `–xcrossfile[={ 1|0}]`

在源文件范围内启用优化和内联。<br/>
通常，编译器的分析范围限定为命令行上的每个独立文件。例如，-O4 的自动内联处理仅限于同一源文件中定义和引用的子程序。<br/>
如果使用 -xcrossfile，编译器会分析命令行上命名的所有文件，就好像这些文件被连接到一个源文件中。<br/>
仅当与 -O4 或 -O5 一起使用时，–xcrossfile 才有效。<br/>
跨文件内联会创建可能但通常不存在的源文件相互依赖性。如果使用 -xcrossfile 编译的一组文件中的任何文件发生了更改，则必须重新编译所有文件，以确保正确地内联新代码。请参见`–inline=[%auto][[ ,][no%]f1,…[ no%]fn]`。<br/>
如果命令行上没有 -xcrossfile，则缺省值为 -xcrossfile=0，而且不执行跨文件优化。要启用跨文件优化，请指定 -xcrossfile（与-xcrossfile=1 等效）。<br/>
编译中的任何 .s 汇编程序源文件不参与跨文件分析。此外，使用 -S 进行编译时，-xcrossfile 标志将被忽略。

- ## `–xdebugformat={dwarf |stabs}`

Sun Studio 编译器会将调试器信息的格式从 "stabs" 格式迁移到 "dwarf" 格式。此发行版的缺省设置为 -xdebugformat=dwarf。<br/>
如果要维护读取调试信息的软件，您现在可以选择将工具从 stabs 格式转换为 dwarf 格式。<br/>
出于移植工具的目的，可以通过此选项来使用新的格式。除非您要维护读取调试器信息的软件，或者特定工具要求使用这些格式之一的调试器信息，否则不需要使用此选项。<br/>
-xdebugformat=stabs 生成使用 stabs 标准格式的调试信息。<br/>
-xdebugformat=dwarf 生成的调试信息采用 dwarf 标准格式。<br/>
如果未指定 -xdebugformat，编译器将假定 -xdebugformat=dwarf。指定此选项而不带参数是不正确的。<br/>
此选项影响使用 -g 选项记录的数据的格式。该信息的某些格式也可以使用此选项进行控制。因此，即使不使用 -g，-xdebugformat 仍会产生影响。<br/>
dbx 和性能分析软件可识别 stabs 和 dwarf 格式，因此使用此选项对其中任一工具的功能并无影响。<br/>
这是过渡性接口，因此会在发行版之间发生更改而不兼容，即使在发行版更新较少时也是如此。stabs 或 dwarf 格式的任何特定字段或值的详细资料也在不断改进。<br/>
使用 dwarfdump(1) 命令确定已编译目标文件或可执行文件中调试信息的格式。

- ## `–xdepend`

与 -depend 等效。

- ## `–xF`

允许性能分析器进行函数级重组。<br/>
允许使用编译器、性能分析器和链接程序重组核心映像中的函数（子程序）。如果使用 -xF 选项编译，然后运行分析器，则可以生成映射文件，该文件可用于优化函数在内存中的排序（具体取决于一起使用这些函数的方式）。可以通过使用链接程序的 -Mmapfile 选项，来指示此后用于生成可执行文件的链接使用该映射。它将可执行文件中的每个函数都放置到单独的部分中。（f95 —M path 选项还将正规文件传递给链接程序，请参见 f95 —Mpath 选项的说明）。<br/>
仅当应用程序文本缺页时间占用了应用程序的大部分时间时，对内存中的子程序进行重组才有用。否则，重组不能提高应用程序的总体性能。有关分析器的详细信息，请参见 Program Performance Analysis Tools 手册。

- ## `–xfilebyteorder= options`

支持 little-endian 和 big-endian 平台之间的文件共享。<br/>
该标志标识无格式 I/O 文件数据的字节顺序和字节对齐。options 必须指定下面的任一组合，但必须至少有一个规范：<br/>
littlemax_align:spec<br/>
bigmax_align:spec<br/>
native:spec<br/>
max_align 为目标平台声明最大字节对齐。允许的值为 1、2、4、8 和 16。对齐适用于 Fortran VAX 结构和 Fortran 派生类型，它们使用依赖于平台的对齐来获得与 C 语言结构的兼容性。<br/>
little 指定平台上的 "little-endian" 文件，其中最大字节对齐为 max_align。例如，little4 指定 32 位 x86 文件；而 little16 描述 64 位 x86 文件。<br/>
big 指定最大对齐为 max_align 的 "big-endian" 文件。例如，big8 描述 32 位 SPARC 文件，而 big16 描述 64 位 SPARC 文件。<br/>
native 指定字节顺序和对齐与编译处理器平台所用的字节顺序和对齐相同的“本机”文件。假定以下内容为“本机”：
![img](/img/in-post/2016-12-21-Fortran-compiler-options/46.png)
spec 必须是包含以下内容的逗号分隔列表：<br/>
%all<br/>
unit<br/>
filename<br/>
%all 指所有文件和逻辑单元，但用 "SCRATCH" 打开的或在 -xfilebyteorder <br/>标志中的其他位置显式命名的文件和逻辑单元除外。%all只能出现一次。<br/>
unit 指程序打开的特定 Fortran 单元号。<br/>
filename 指程序打开的特定 Fortran 文件名。<br/>
示例：<br/>
-xfilebyteorder=little4:1,2,afile.in,big8:9,bfile.out,12 <br/>
-xfilebyteorder=little8:%all,big16:20<br/>
此选项不适用于使用 STATUS="SCRATCH" 打开的文件。对这些文件执行的 I/O 操作始终依照本机处理器的字节顺序和字节对齐。<br/>
如果命令行中没有出现 -xfilebyteorder，则第一个缺省设置为 -xfilebyteorder=native:%all。<br/>
在此选项中只能声明一次文件名或单元号。<br/>
如果在命令行中出现了 -xfilebyteorder，则它必须至少带有 little、big 或 native 规范之一。<br/>
将此标志没有显式声明的文件假定为本机文件。例如，如果使用 -xfilebyteorder=little4:zork.out 进行编译，就会将 zork.out 声明为最大数据对齐为 4 字节的 little-endian 32 位 x86 文件。程序中的所有其他文件均是本机文件。<br/>
如果为文件指定的字节顺序与本机处理器相同，但指定了不同的对齐，即使没有进行字节交换，也会使用相应的填充。例如，如果针对 64 位 x86 平台使用 -m64 进行编译，并指定了 -xfilebyteorder=little4:filename，就会出现这种情况。<br/>
大端字节序和小端字节序平台之间共享的数据记录中的声明类型必须具有相同的大小。例如，使用 -xtypemap=integer:64,real:64,double:64 编译的 x86 可执行文件不能读取使用 -xtypemap=integer:64,real:64,double:128 编译的 SPARC 可执行文件生成的文件，因为二者的缺省双精度数据类型具有不同的大小。（不过请注意，从 Sun Studio 12 Update 1 发行版开始，x64 处理器上接受 double:128。）<br/>
如果在一个平台上使用了更改 VAX 结构内的组件对齐方式的选项（如 —vax=struct_align）或更改派生类型内的组件对齐方式的选项（如 —aligncommon 或 —dalign），则在共享同一无格式数据文件（其内容受对齐选项影响）的其他平台上也要使用同一对齐选项。<br/>
如果使用整个 UNION/MAP 数据对象对指定为非本机的文件执行 I/O 操作，则会导致运行时 I/O 错误。只能使用 MAP 的个别成员（而不能使用包含 UNION/MAP 的整个 VAX 记录）对非本机文件执行 I/O 操作。

- ## `–xhasc[={ yes|no}]`

将霍尔瑞斯常量视为实际参数列表中的字符串。<br/>
如果使用 -xhasc=yes，则当霍尔瑞斯常量在子例程或函数调用中作为实际参数出现时，编译器将霍尔瑞斯常量视为字符串。这是缺省值，并且符合 Fortran 标准。（编译器生成的实际调用列表包含每个字符串的隐藏字符串长度。）<br/>
如果使用 -xhasc=no，则霍尔瑞斯常量将被视为子程序调用中的无类型值，并且只将它们的地址放在实际参数列表中。（传递到子程序的实际调用列表中不会生成字符串长度。）<br/>
如果例程调用带有霍尔瑞斯常量的子程序，并且调用的子程序要求参数为 INTEGER（或除 CHARACTER 以外的任意类型），请使用 -xhasc=no 编译例程。<br/>
示例：
![img](/img/in-post/2016-12-21-Fortran-compiler-options/47.png)
将 4habcd 传递到 z 是通过使用 -xhasc=no 进行编译来正确处理的。<br/>
提供此标记是为了帮助移植传统的 Fortran 77 程序。

- ## `–xhelp={readme| flags}`

显示摘要帮助信息。<br/>
-xhelp=readme<br/>
显示此发行版的编译器的联机自述文件。<br/>
-xhelp=flags<br/>
列出编译器选项标志。与 -help 等效。

- ## `–xhwcprof[={enable | disable}]`

(SPARC) 为数据空间分析启用编译器支持。<br/>
启用 -xhwcprof 后，编译器将生成信息，该信息可帮助工具将已进行分析的装入指令和存储指令与它们所引用的数据类型和结构成员（结合使用-g 生成的符号信息）相关联。 它将配置文件数据同目标文件的数据空间（而不是指令空间）相关联，并对行为进行洞察，而这仅从指令配置中是无法轻易获得的。<br/>
当可以使用 -xhwcprof 编译指定的目标文件集时，如果对应用程序中的所有目标文件应用该选项，则该选项最为有用。它能全面识别并关联分布在应用程序目标文件中的所有内存引用。<br/>
如果分别在单独的步骤中进行编译和链接，最好在链接时使用 -xhwcprof。<br/>
-xhwcprof=enable 或 -xhwcprof=disable 的实例将会覆盖同一命令行中 -xhwcprof 的所有以前的实例。<br/>
在缺省情况下，禁用 -xhwcprof。指定不带任何参数的 -xhwcprof 与 -xhwcprof=enable 等效。<br/>
-xhwcprof 要求打开优化，并将调试数据格式设置为 dwarf (-xdebugformat=dwarf)，这是该发行版 Sun Studio 的缺省设置。<br/>
组合使用 -xhwcprof 和 -g 会增加编译器临时文件的存储需求，而且比单独指定 -xhwcprof 和 -g 所引起的增加总量还多。<br/>
下列命令可编译 example.f，并可为硬件计数器分析以及针对使用 DWARF 符号的数据类型和结构成员的符号分析指定支持：<br/>
`f95 -c -O -xhwcprof -g example.f`<br/>
有关基于硬件计数器的分析的详细信息，请参见 Sun Studio 性能分析器手册。

- ## `–xia[={ widestneed|strict}]`

(Solaris) 启用区间运算扩展并设置合适的浮点环境。<br/>
如果未指定此选项，则缺省值为 -xia=widestneed。<br/>
《Interval Arithmetic Programming Reference》中详细说明了区间运算的 Fortran 扩展。另请参见3.4.130 –xinterval[={widestneed|strict|no}]。<br/>
-xia 标志是一个宏，其扩展如下：
![img](/img/in-post/2016-12-21-Fortran-compiler-options/48.png)

- ## `–xinline= list`

与 -inline 等效。

- ## `-xinstrument=[%no]datarace`

指定此选项编译您的程序并为其提供程序设备，以供线程分析器进行分析。<br/>
（有关线程分析器的详细信息，请参见 tha(1)。）<br/>
通过使用此选项进行编译，您可以随后使用性能分析器通过 collect -r races 运行已提供了程序设备的程序，来创建数据争用检测试验。可以单独运行已提供了程序设备的代码，但其运行速度将非常缓慢。<br/>
指定 -xinstrument=no%datarace 关闭该功能。这是缺省值。<br/>
必须为 -xinstrument 指定一个参数。<br/>
如果分步进行编译和链接，则必须在编译和链接步骤中都指定 -xinstrument=datarace。<br/>
此选项定义了预处理程序令牌 __THA_NOTIFY。可指定 #ifdef __THA_NOTIFY 来保护对 libtha (3) 例程的调用。<br/>
此选项还设置 -g。

- ## `–xinterval[={ widestneed|strict|no}]`

(Solaris) 启用区间运算扩展。<br/>
可选值可以是 no、widestneed 或 strict。如果未指定，则缺省值为 widestneed。<br/>
![img](/img/in-post/2016-12-21-Fortran-compiler-options/49.png)
《Fortran 95 Interval Arithmetic Programming Reference》中详细说明了区间运算的 Fortran 扩展。另请参见`–xia[={widestneed|strict}]`。

- ## `–xipo[={ 0|1|2}]`

执行过程间的优化。<br/>
通过调用一次过程间分析来执行整个程序的优化。与 -xcrossfile 不同的是，-xipo 将在链接步骤中跨所有目标文件执行优化，并且不仅仅限于编译命令上的源文件。<br/>
在编译和链接大型多文件应用程序时，-xipo 特别有用。用该标志编译的对象目标文件具有在这些文件内编译的分析信息，这些信息实现了在源码和预编译的程序文件中的过程间分析。不过，分析和优化仅限于用 -xipo 编译的目标文件，而不扩展到库的目标文件。<br/>
-xipo=0 可禁用过程间分析，-xipo=1 可启用过程间分析。-xipo=2 可添加过程间别名分析以及内存分配和布局优化，以便改善高速缓存性能。缺省值为 -xipo=0，如果指定了不带值的 -xipo，则使用 -xipo=1。<br/>
如果使用 -xipo=2 进行编译，未使用 -xipo=2 编译的函数或子例程（例如，库）不能调用使用 -xipo=2 编译的函数或子例程。<br/>
例如，如果您干预 malloc() 函数并使用 -xipo=2 编译您自己的 malloc()，则引用与您的代码链接的任何库中的 malloc() 的所有函数也必须使用 -xipo=2 进行编译。由于这对于系统库不大可能，因此您自己的 malloc 不应该使用 -xipo=2 进行编译。<br/>
在不同的步骤中进行编译和链接时，必须在这两个步骤中都指定 -xipo 才有效。<br/>
在一个编译/链接步骤中使用 -xipo 的示例：<br/>
`demo% f95 -xipo -xO4 -o prog  part1.f part2.f part3.f`<br/>
优化器在三个源文件之间执行交叉文件内联。该操作是在最终的链接步骤中完成的，因此源文件的编译工作不必全在一个编译过程中完成，可以跨多个不同的编译过程，但每个编译过程都需要指定 -xipo。<br/>
在不同的编译/链接步骤中使用 -xipo 的示例：<br/>
`demo% f95 -xipo -xO4 -c part1.f part2.f`<br/>
`demo% f95 -xipo -xO4 -c part3.f`<br/>
`demo% f95 -xipo -xO4 -o prog  part1.o part2.o part3.o`<br/>
在编译步骤中创建的目标文件具有在文件内部编译的附加分析信息，这样就可以在链接步骤中执行跨文件优化。<br/>
即使使用 -xipo 进行编译，也存在库不参与跨文件过程间分析的限制，如下例所示：
![img](/img/in-post/2016-12-21-Fortran-compiler-options/50.png)
在此例中，过程间优化将在 one.f、two.f 和 three.f 之间以及 main.f 和 four.f 之间执行，但不在 main.f 或 four.f 与mylib.a 上的例程之间执行。（第一个编译可能生成有关未定义符号的警告，但仍可执行过程间优化，因为过程间优化是编译和链接的一个步骤。）<br/>
关于 -xipo 的其他重要信息：<br/>
至少需要优化级别 -xO4<br/>
与 -xcrossfile 冲突；如果一起使用，将导致编译错误<br/>
如果在构造中使用的目标文件对于并行运行的链接步骤通用，则使用并行生成工具构建采用 -xipo 编译的可执行文件会产生问题。每个链接步骤都应有自己的目标文件副本，并且该副本应在链接前进行优化。<br/>
未使用 -xipo 编译的对象可以与使用 -xipo 编译的对象自由链接。<br/>
由于执行跨文件优化时需要附加信息，因此 -xipo 选项会生成更大的目标文件。不过，该附加信息不会成为最终的二进制可执行文件的一部分。可执行程序大小的增加是由于执行额外的优化导致的。<br/>
在此发行版中，跨文件子程序内联是由 -xipo 执行的唯一过程间优化。<br/>
.s 汇编语言文件不参与过程间分析。<br/>
如果使用 -S 进行编译，则忽略 -xipo 标志。<br/>
何时不使用 -xipo 进行编译：<br/>
在链接步骤中使用目标文件集合时，编译器试图执行整个程序的分析和优化。对于该目标文件集合中定义的任何函数或子例程 foo()，编译器作出以下两个假定：<br/>
(1) 运行时，在该目标文件集合外部定义的其他例程将不显式调用 foo()<br/>
(2) 从该目标文件集合中的任何例程调用 foo() 时，将不会受到在该目标文件集合外部定义的不同版本的 foo() 的干预。<br/>
如果假定 (1) 对给定应用程序不成立，请勿使用 -xipo=2 进行编译。如果假定 (2) 不成立，请勿使用 -xipo=1 或 -xipo=2 进行编译。<br/>
例如，考虑使用您自己的源版本干预 malloc() 函数并使用 -xipo=2 进行编译。然后，任何库中引用与您的代码链接的 malloc() 的所有函数也必须使用 -xipo=2 进行编译，并且它们的目标文件将不需要参与链接步骤。由于这对于系统库不大可能，因此您自己的 malloc 不应该使用-xipo=2 进行编译。<br/>
另举一例，假定您使用以下两个外部调用来生成共享库：两个不同的源文件中的 foo() 和 bar()，并且 bar() 调用其主体内的 foo()。如果有可能在运行时干预函数调用 foo()，则不要使用 -xipo=1 或 -xipo=2 编译 foo() 或 bar() 的任何一个源文件。否则，foo()可以内联到 bar()，这会导致在使用 -xipo 编译时出现不正确的结果。

- ## `–xipo_archive[={ none|readonly|writeback}]`

(SPARC) 允许跨文件优化包括归档 (.a) 库。<br/>
值必须是以下项之一：
![img](/img/in-post/2016-12-21-Fortran-compiler-options/51.png)
如果未指定 -xipo_archive 的设置，编译器将假定 -xipo_archive=none。

- ## `–xjobs= n`

使用多个处理器进行编译。<br/>
指定 -xjobs 选项可设置编译器完成其任务需创建的进程数。在多 CPU 计算机上，该选项可以缩短生成时间。在此发行版的 f95 编译器中，-xjobs 只能与 -xipo 选项一起使用。如果指定 -xjobs=n，过程间优化器就将 n 作为其在编译不同文件时可调用的最大代码生成器实例数。<br/>
通常，n 的安全值等于 1.5 乘以可用虚拟处理器数。由于上下文在产生的作业间切换的开销，使用等于可用虚拟处理器数量整数倍的值会降低性能。此外，如果使用很大的数值会耗尽系统资源（如交换空间）。<br/>
指定 -xjobs 时务必要指定值。否则会发出错误诊断并使编译终止。<br/>
在出现最合适的实例之前，-xjobs 的多个实例在命令行上会互相覆盖。<br/>
以下示例在有两个处理器的系统上进行的编译，速度比使用相同命令但没有 -xjobs 选项时进行的编译快。<br/>
`example% f95 -xipo -xO4 -xjobs=3 t1.f t2.f t3.f`

- ## `–xknown_lib=library_list`

识别对已知库的调用。<br/>
如果指定此选项，编译器会将对某些已知库的调用视为内部函数，从而忽略用户提供的任何版本。这样，编译器就可以根据它具备的有关该库的专业知识来对库例程调用进行优化。<br/>
library_list 是当前应用于 blas、blas1、blas2、blas3 和内部函数的关键字列表（用逗号分隔）。编译器能够识别对以下 BLAS1、BLAS2 和 BLAS3 库例程的调用，并且能够针对 Sun 性能库实现自由地进行正确优化。编译器将忽略这些库例程的用户提供版本，并链接到 Sun 性能库中的 BLAS 例程。
![img](/img/in-post/2016-12-21-Fortran-compiler-options/52.png)

- ## `–xlang=f77`

(SPARC) 准备与使用更早版本的 f77 编译的运行时库链接。<br/>
f95 -xlang=f77 表示与 f77compat 库进行链接，这是将 f95 目标文件与更早的 Fortran 77 目标文件相链接的简便方法。使用此标志进行编译，可确保正确的运行时环境。<br/>
如果将 f95 和 f77 已编译对象一起链接到一个可执行文件，请使用 f95 -xlang=f77。<br/>
使用 -xlang 进行编译时，请注意以下事项：<br/>
不要同时使用 -xnolib 和 -xlang 编译。<br/>
将 Fortran 目标文件和 C++ 混合使用时，请使用 C++ 编译器进行链接，并在 CC 命令行上指定 -xlang=f95。<br/>
将 C++ 对象与使用任何并行化选项编译的 Fortran 目标文件混合使用时，链接 CC 命令行还必须指定 -mt。

- ## `–xlibmil`

与 -libmil 等效。

- ## `–xlibmopt`

使用优化的数学例程库。<br/>
使用为速度进行了优化的选定数学例程。此选项通常生成更快的代码。它可能生成稍有不同的结果；如果是这样，通常是最后一位不同。该库选项在命令行上的顺序并不重要。

- ## `–xlic_lib=sunperf`

与 Sun 性能库链接。<br/>
例如：<br/>
`f95 -o pgx -fast pgx.f -xlic_lib=sunperf`<br/>
与 -l 一样，此选项应位于命令行上的所有源文件和目标文件名称之后。<br/>
要与 Sun 性能库链接，必须使用此选项。（请参见《Sun Performance Library User's Guide》。）

- ## `–xlicinfo`

（已过时）编译器无提示地忽略。

- ## `–xlinkopt[={ 1|2|0}]`

(SPARC) 对可重定位目标文件执行链接时优化。<br/>
后优化器在链接时对二进制目标代码执行一些高级性能优化。可以使用可选值来设置执行的优化级别，可选值必须为 0、1 或 2。
![img](/img/in-post/2016-12-21-Fortran-compiler-options/53.png)
指定不带值的 -xlinkopt 标志即表示 -xlinkopt=1。<br/>
这些优化在链接时通过分析二进制目标代码来执行。虽然未重写目标文件，但生成的可执行代码可能与初始目标代码不同。<br/>
当与分析反馈一起用于编译整个程序时，此选项最有效。<br/>
如果在不同的步骤中进行编译，则 -xlinkopt 必须既出现在编译步骤中，也出现在链接步骤中。<br/>
`demo% f95 -c -xlinkopt a.f95 b.f95`<br/>
`demo% f95 -o myprog -xlinkopt=2 a.o b.o`<br/>
请注意，仅当编译器链接时才使用级别参数。在以上示例中，即使二进制目标文件是用缺省级别 1 编译的，使用的后优化级别也是 2。<br/>
不能将链接时后优化器与增量链接程序 ild 一起使用。-xlinkopt 标志会将缺省链接程序设置为 ld。如果使用 -xildon 标志显式启用增量链接程序，将禁用 -xlinkopt 选项（如果同时指定了二者）。<br/>
要使 -xlinkopt 选项有用，至少程序中的一些例程（但未必是全部例程）必须使用此选项编译。优化器仍可以对未使用 -xlinkopt 进行编译的二进制目标文件执行部分受限的优化。<br/>
-xlinkopt 选项将优化位于编译器命令行上的静态库中的代码，但会跳过位于命令行上的共享（动态）库中的代码且不对其进行优化。生成共享库（用 -G 编译）时，您也可以使用 -xlinkopt。<br/>
与运行时分析反馈一起使用时，链接时后优化器最有效。分析功能会展示代码中最常用和最不常用的部分，并指示优化器相应地进行处理。这对大型应用程序尤为重要，因为在链接时执行代码优化放置可降低指令高速缓存未命中数。通常，会按照以下方式进行编译：<br/>
`demo% f95 -o progt -xO5 -xprofile=collect:prog file.f95`<br/>
`demo% progt`<br/>
`demo% f95 -o prog -xO5 -xprofile=use:prog -xlinkopt file.95`<br/>
有关使用分析反馈的详细信息，请参见 -xprofile 选项。<br/>
请注意，使用此选项编译会略微延长链接时间。目标文件的大小也会增加，但可执行文件的大小保持不变。如果使用 -xlinkopt 和 -g 标志进行编译，则会因包括调试信息而增加了可执行文件的大小。

- ## `–xloopinfo`

与 -loopinfo 等效。

- ## `–xmaxopt[= n]`

启用优化 pragma 并设置最大优化级别。<br/>
n 具有值 1 至 5，分别对应于优化级别 -O1 至 -O5。如果未指定，编译器将使用 5。<br/>
如果 C$PRAGMA SUN OPT=n 指令出现在源输入中，此选项将启用该指令。不使用此选项时，编译器将这些行视为注释。请参见OPT指令。<br/>
如果此 pragma 与某个优化级别一起出现，而该优化级别高于 -xmaxopt 标志上的最高级别，则编译器将使用由 -xmaxopt 设置的级别。

- ## `–xmemalign[= <a><b>]`

(SPARC) 指定未对齐数据访问的最大假定内存对齐和行为。<br/>
对于可在编译时确定对齐的内存访问，编译器会为数据对齐生成相应的装入/存储指令序列。<br/>
对于不能在编译时确定对齐的内存访问，编译器必须假定一个对齐以生成所需的装入/存储序列。<br/>
使用 -xmemalign 标志，用户可以指定因上述未确定情况编译器要假定的数据最大内存对齐。它还指定了在运行时发生未对齐内存访问时的错误行为。<br/>
指定的值包含两个部分： 数值对齐值 < a >，以及字母行为标志 < b >。<br/>
对齐 < a > 的允许值有：<br/>
1假定最多 1 字节对齐。<br/>
2假定最多 2 字节对齐。<br/>
4假定最多 4 字节对齐。<br/>
8假定最多 8 字节对齐。<br/>
16假定最多 16 字节对齐。<br/>
访问未对齐数据时错误行为 < b > 的允许值有：<br/>
i解释访问并继续执行。<br/>
s产生信号 SIGBUS。<br/>
f在 64 位平台上，产生信号 SIGBUS 仅对齐少于或等于 4，否则将解释访问并继续执行。在其他平台上，f 与 i 等效。<br/>
如果在不指定 -xmemalign 的情况下进行编译，缺省值为：<br/>
针对 32 位平台的 8i<br/>
针对采用 C 和 C++ 的 64 位平台的 8s<br/>
针对采用 Fortran 的 64 位平台的 8f<br/>
对于所有平台，-xmemalign 不带值显示时的缺省值为 1i。<br/>
请注意，-xmemalign 本身并不强制进行任何特殊的数据对齐。使用 -dalign 或 -aligncommon 可强制进行数据对齐。<br/>
此外，只要链接到使用 b 值 i 或 f 编译的目标文件，就必须指定 -xmemalign。<br/>
-dalign 选项是一个宏：<br/>
-dalign 是 -xmemalign=8s -aligncommon=16 的宏<br/>
不要将 -aligncommon=1 与 -xmemalign 一起使用，因为这些声明会发生冲突，在某些平台和配置上可能会引发段故障。<br/>
有关详细信息，请参见`-aligncommon[={ 1|2|4|8| 16}]`。

- ## `–xmodel=[small | kernel | medium]`

(x86) 在 Solaris x64 平台上为共享对象指定数据地址模型。<br/>
使用 -xmodel 选项，编译器可以为 Solaris x64 平台创建 64 位共享对象，并且只应为此类对象的编译而指定该选项。<br/>
仅当在启用了 64 位的 x86 平台 ("x64") 上指定了 -m64 时，此选项才有效。<br/>
small:此选项按小型模型生成代码，在该模型中，所执行代码的虚拟地址在链接时已知，且确定所有符号都位于 0 到 231 – 224 - 1 范围内的虚拟地址中。<br/>
kernel:为内核模型生成代码，在该模型中，所有符号都定义在 264 - 231 到 264 - 224 范围内。<br/>
medium:按中等模型生成代码，在该模型中， 不对数据段的符号引用范围进行假定。文本段的大小和地址的限制与小型代码模型的限制相同。使用 —m64 编译含有大量静态数据的应用程序时，可能需要使用 —xmodel=medium。<br/>
如果未指定 -xmodel，编译器将假定 -xmodel=small。如果指定没有参数的 -xmodel，将出现错误。<br/>
只要您确保所访问的对象位于相应的范围内，就没有必要使用该选项编译所有的例程。

- ## `–xnolib`

与 -nolib 等效。

- ## `–xnolibmil`

与 -nolibmil 等效。

- ## `–xnolibmopt`

不使用快速数学库。<br/>
与 -fast 一起使用可以覆盖对优化数学库的链接：<br/>
`f95 -fast -xnolibmopt …`

- ## `–xOn`

与 -On 等效。

- ## `–xopenmp[={ parallel|noopt|none}]`

启用通过 Fortran OpenMP 版本 3.0 指令进行的显式并行化。<br/>
此标志接受以下可选关键字子选项：<br/>
parallel<br/>
启用对 OpenMP Pragma 的识别，并相应地并行化程序。<br/>
-xopenmp=parallel 的最低优化级别是 -xO3。如有必要，编译器将优化级别从较低级别更改为 -xO3，并发出警告。<br/>
定义预处理程序标记 _OPENMP。<br/>
自动调用 -stackvar。<br/>
noopt<br/>
启用对 OpenMP Pragma 的识别，并相应地并行化程序。<br/>
如果优化级别低于 -xO3，则编译器不提升它。如果将优化显式设置为低于 -xO3 的级别（如 -xO2 -xopenmp=noopt），则编译器将发出错误。如果没有使用 -xopenmp=noopt 指定优化级别，则会识别 OpenMP Pragma，并相应地对程序进行并行处理，但不进行优化。<br/>
定义预处理程序标记 _OPENMP。<br/>
自动调用 -stackvar。<br/>
none<br/>
禁用对 OpenMP Pragma 的识别，并且不更改优化级别。（这是编译器的缺省值。）<br/>
指定的无子选项关键字的 -xopenmp 与 -xopenmp=parallel 等效。请注意，此缺省值在以后的发行版中可能会有所变化。<br/>
要使用 dbx 调试 OpenMP 程序，请使用 -g -xopenmp=noopt 进行编译，以便能够在并行区域内设置断点并显示变量的内容。<br/>
《OpenMP API 用户指南》中对 OpenMP 指令进行了概述。<br/>
要在多线程环境中运行已并行化的程序，必须在执行之前设置 PARALLEL（或 OMP_NUM_THREADS）环境变量。这会将程序可以创建的最大线程数通知给运行时系统。缺省值为 1。通常会将 PARALLEL 或 OMP_NUM_THREADS 变量设置为目标平台上可用的虚拟处理器数。<br/>
要启用嵌套并行操作，必须将 OMP_NESTED 环境变量设置为 TRUE。缺省情况下，禁用嵌套并行操作。有关嵌套并行操作的详细信息，请参见 Sun Studio《OpenMP API 用户指南》。<br/>
OpenMP 要求预处理程序符号 _OPENMP 的定义中包含十进制值 YYYYMM，其中 YYYY 和 MM 是实现所支持的 OpenMP Fortran API 版本的年份和月份名称。对于当前 Sun Studio 发行版，该值是 200830（表示 OpenMP 3.0 版）。<br/>
如果是在不同的步骤中进行编译和链接，还要在链接步骤中指定 -xopenmp。在编译包含 OpenMP 指令的库时，这一点尤为重要。

- ## `–xpad`

与 -pad 等效。

- ## `–xpagesize= size`

为栈和堆设置首选页面大小。<br/>
在 SPARC 平台上，size 值必须是以下值之一：<br/>
8K、64K、512K、4M、32M、256M、2G、16G 或 default<br/>
在 x86 平台上，size 值必须是以下值之一：<br/>
4K、2M、4M 或 default<br/>
例如： -xpagesize=4M<br/>
并非所有这些页面大小在所有平台上都受支持，具体取决于体系结构和 Solaris 环境。指定的页面大小对于目标平台上的 Solaris 操作环境必须是有效的页面大小，其值由 getpagesizes(3C) 返回。如果不是，此请求在运行时将被忽略。Solaris 环境不保证能够支持页面大小请求。<br/>
您可以使用 pmap(1) 或 meminfo(2) 来确定运行的程序是否收到所请求的页面大小。<br/>
如果指定了 -xpagesize=default，该标志将被忽略；如果指定了不带 size 值的 -xpagesize，则与 -xpagesize=default 等效。<br/>
此选项是组合使用 -xpagesize_heap=size -xpagesize_stack=size 的宏。这两个选项与 -xpagesize 接受相同的参数。可以通过指定-xpagesize=size 来为二者设置相同的值，或分别为它们指定不同的值。<br/>
使用该标志进行编译，与使用等效选项将 LD_PRELOAD 环境变量设置为 mpss.so.1 或在启动程序之前使用等效选项运行 Solaris 9 命令ppgsz(1) 具有相同的效果。有关详细信息，请参见 Solaris 9 手册页。

- ## `–xpagesize_heap= size`

为堆设置首选页面大小。<br/>
size 值与所述的 -xpagesize 值相同。<br/>
有关详细信息，请参见 -xpagesize。

- ## `–xpagesize_stack= size`

(SPARC)为栈设置首选页面大小。<br/>
size 值与所述的 -xpagesize 值相同。<br/>
有关详细信息，请参见 -xpagesize。

- ## `-xpec[={ yes|no}]`

生成 PEC（Portable Executable Code，可移植执行代码）二进制文件。<br/>
PEC 二进制文件可用于自动调优系统 (Automatic Tuning System, ATS)。有关 ATS 的更多信息，请访问http://cooltools.sunsource.net/ats/index.html。<br/>
使用 -xpec 生成的二进制文件通常要比不使用该选项生成的文件大 5 到 10 倍。缺省值为 -xpec=no。<br/>
不带参数的 -xpec 与 -xpec=yes 等效。

- ## `–xpg`

与 -pg 等效。

- ## `–xpp={fpp| cpp}`

选择源文件预处理程序。<br/>
缺省值为 -xpp=fpp。<br/>
编译器使用 fpp(1) 来预处理 .F、.F95 或 .F03 源文件。此预处理程序适用于 Fortran。以前的版本使用标准 C 预处理程序 cpp。要选择cpp，请指定 -xpp=cpp。

- ## `–xprefetch[= a[,a]]`

在支持预取的体系结构上启用预取指令。<br/>
有关 Fortran PREFETCH 指令的说明，请参见PREFETCH 指令。<br/>
a 必须是以下值之一：<br/>
auto<br/>
启用预取指令的自动生成<br/>
no%auto<br/>
禁用预取指令的自动生成<br/>
explicit<br/>
启用显式预取宏（仅限 SPARC）<br/>
no%explicit<br/>
禁用显式预取宏（仅限 SPARC）<br/>
latx:factor<br/>
(SPARC) 按指定的因子调整编译器的假定预取到装入的延迟和预取到存储的延迟。该因子必须是正浮点数或整数。<br/>
如果要在较大的 SPARC 多处理器上运行计算密集的代码，您会发现使用 -xprefetch=latx:factor 有很多优点。该选项指示代码生成器按照指定的因子调节在预取及其相关的装入或存储之间的缺省延迟时间。<br/>
预取延迟是从执行预取指令到所预取的数据在高速缓存中可用那一刻之间的硬件延迟。在确定发出预取指令到发出使用所预取数据的装入或存储指令之间的间隔时，编译器就采用预取延迟值。<br/>
注 –<br/><br/>
在预取和装入之间采用的延迟可能与在预取和存储之间采用的延迟不同。<br/>
编译器可以在众多计算机与应用程序间调整预取机制，以获得最佳性能。这种调整并非总能达到最优。对于占用大量内存的应用程序，尤其是要在大型多处理器上运行的应用程序，可以通过增加预取延迟值来提高性能。要增加值，请使用大于 1 的因子。介于 .5 和 2.0 之间的值最有可能提供最佳性能。<br/>
对于数据集完全位于外部高速缓存中的应用程序，可以通过减小预取延迟值来提高性能。要减小此值，请使用小于 1 的因子。<br/>
要使用 -xprefetch=latx:factor 选项，请首先使用接近 1.0 的因子值并对应用程序运行性能测试。然后适当增加或减小该因子，并再次运行性能测试。继续调整因子并运行性能测试，直到获得最佳性能。以很小的增量逐渐增加或减小因子时，前几步中不会看到性能差异，之后会突然出现差异，然后再趋于稳定。<br/>
yes<br/>
-xprefetch=yes 与 -xprefetch=auto,explicit 相同<br/>
no<br/>
-xprefetch=no 与 -xprefetch=no%auto,no%explicit 相同<br/>
使用 -xprefetch、-xprefetch=auto 和 -xprefetch=yes 时，编译器就可以将预取指令插入到其生成的代码中。该操作会提高支持预取的体系结构的性能。<br/>
如果未指定 -xprefetch，则假定为 -xprefetch=no%auto,explicit。<br/>
如果仅指定了 -xprefetch，则假定为 -xprefetch=auto,explicit。<br/>
除非使用不带任何参数或具有 auto 或 yes 参数的 -xprefetch 进行显式覆盖，否则使用缺省值 no%auto。例如，-xprefetch=explicit 与 -xprefetch=explicit,no%auto 相同。<br/>
除非使用参数 no%explicit 或 no 进行显式覆盖，否则使用缺省值 explicit。例如，-xprefetch=auto 与 -xprefetch=auto,explicit 相同。<br/>
如果使用 -xprefetch 或 -xprefetch=yes 等启用了自动预取，但未指定延迟因子，则假定 -xprefetch=latx:1.0。<br/>
如果使用 -xprefetch=explicit，编译器将能够识别以下指令：
![img](/img/in-post/2016-12-21-Fortran-compiler-options/54.png)
-xchip 设置影响假定延迟的决定以及 latx:factor 设置的结果。<br/>
仅当在 SPARC 处理器上启用了自动预取 (auto) 时，latx:factor 子选项才有效。<br/>
显式预取只应在度量支持的特殊环境下使用。<br/>
因为编译器可以在众多计算机与应用程序间调整预取机制以获得最佳性能，所以当性能测试指示性能明显提高时，应当只使用 -xprefetch=latx:factor。假定的预取延迟在不同发行版本中是不同的。因此，无论何时切换到不同的发行版本，强烈建议重新测试延迟因子对性能的影响。

- ## `–xprefetch_auto_type=indirect_array_access`

为间接访问的数据数组生成间接预取。<br/>
以生成直接内存访问预取的相同方式来生成由选项 -xprefetch_level={1|2|3} 指定的循环的间接预取。可添加前缀 no% 否定声明。<br/>
缺省值为 -xprefetch_auto_type=no%indirect_array_access。<br/>
要求 -xprefetch=auto 以及优化级别 -xO3 或更高级别。<br/>
诸如 -xdepend 之类的选项可以影响计算间接预取候选项的主动性，进而影响由于更好的内存别名歧义消除信息而发生的自动间接预取插入的主动性。

- ## `-xprefetch_level={ 1|2|3}`

控制预取指令的自动生成。<br/>
在以下情况下编译时，此选项才有效：<br/>
-xprefetch=auto，<br/>
使用优化级别 3 或更高。<br/>
在支持预取的平台上。<br/>
如果未指定 -xprefetch_level，则 -xprefetch=auto 的缺省值为级别 2。<br/>
预取级别 2 比级别 1 产生更多的预取指令机会。预取级别 3 比级别 2 生成更多的预取指令。<br/>
在早期的 SPARC 或 x86 平台上，预取级别 2 和 3 可能不会生效。

- ## `–xprofile={collect [:name]| use[:name]| tcov}`

使用运行时分析数据收集或优化，或执行基本块覆盖分析。<br/>
通过为编译器提供运行时性能反馈，增强了使用高优化级别 (-xO5) 进行编译的效果。为了生成编译器执行最佳优化所需的分析反馈，您必须先使用 -xprofile=collect 进行编译，再对典型数据集运行可执行文件，然后在最高优化级别使用 -xprofile=use 重新编译。<br/>
有关 —xprofile 和环境变量的更多信息，另请参见 f95(1) 手册页。<br/>
collect[: name]<br/>
优化器使用 -xprofile=use 收集并保存执行频率数据以备将来使用。编译器生成可测量语句执行频率的代码。<br/>
name 是执行程序时用于存储配置文件数据的目录名称（可选）。如果指定，name 应为 UNIX 绝对路径名。如果未指定 name，则执行program 时，会将已进行分析且名称为 program 的程序的配置文件数据存储在当前工作目录下名为 program.profile 的目录中。<br/>
在运行时，使用 -xprofile=collect: name 编译的程序在缺省情况下会创建子目录 name .profile 来保存运行时反馈信息。程序将其运行时配置文件数据写入该子目录中名为 feedback 的文件。如果多次运行程序，那么执行频率数据会累积在 feedback 文件中；也就是说，以前运行的输出不会丢失。<br/>
您可以设置环境变量 SUN_PROFDATA 和 SUN_PROFDATA_DIR，来控制使用 -xprofile=collect 编译的程序在其中写入其运行时配置文件数据的文件和目录。设置这些变量后，使用 -xprofile=collect 编译的程序会将其配置文件数据写入$SUN_PROFDATA_DIR/$SUN_PROFDATA中。<br/>
这些环境变量同样控制由 tcov 写入的配置文件数据文件的路径和名称，如 tcov(1) 手册页中所述。<br/>
配置文件集合是“MT 安全的”。也就是说，对于通过使用 -mt 进行编译并直接调用多任务库来执行自身多任务处理的程序，如果对它进行分析将产生准确的结果。<br/>
当在不同的步骤中进行编译和链接时，如果 -xprofile=collect 出现在编译步骤中，那么在链接步骤中也必须指定它。<br/>
use[: nm]<br/>
使用执行频率数据有策略地在优化级别 -xO5 进行优化。<br/>
与 collect:nm 一样，nm 是可选的，可用于指定程序的名称。<br/>
程序是使用以前生成并保存在配置文件数据文件中的执行频率数据优化的，此数据是先前执行用 -xprofile=collect 编译的程序时写入的。<br/>
源文件和其他编译器选项必须与用于编译的源文件和编译器选项完全一致，该编译创建了生成 feedback 文件的编译程序。如果使用 -xprofile=collect: nm 进行编译，则相同的程序名称 nm 必须出现在以下优化编译中：-xprofile=use: nm。<br/>
有关加速收集阶段和使用阶段之间的编译的说明，另请参见 -xprofile_ircache。<br/>
有关控制编译器在哪里查找配置文件数据文件的说明，另请参见 -xprofile_pathmap。<br/>
tcov<br/>
使用“新”样式的 tcov 的基本块覆盖分析。优化级别必须为 -O2 或更高。<br/>
代码指令与 -a 选项的代码指令类似，但不再为每个源文件生成 .d 文件。相反，会生成一个文件，并且该文件的名称是根据最终的可执行文件命名的。例如，如果 stuff 是可执行文件，则 stuff.profile/tcovd 是数据文件。<br/>
运行 tcov 时，您必须将 -x 选项传递给它，以便它使用新式数据。否则，tcov 使用原来的 .d 文件（如果有；这是数据的缺省值），并产生不可预测的输出。<br/>
与 -a 选项不同，TCOVDIR 环境变量在编译时不起作用。但是，在程序运行时会使用它的值来确定在哪里创建配置文件子目录。<br/>
有关详细信息，请参见 tcov(1) 手册页、《Fortran 编程指南》的“性能剖析”一章以及《Program Performance Analysis Tools》手册。<br/>
注 –<br/>
如果因 -O4 或 -inline 而存在子程序的内联处理，则 tcov 生成的报告可能不可靠。不会记录对已经内联的例程的调用的覆盖。

- ## `–xprofile_ircache[ =path]`

(SPARC) 保存并重用收集阶段和使用配置文件阶段之间的编译数据。<br/>
在使用阶段，与 -xprofile=collect|use 一起使用会重用收集阶段保存的编译数据，从而可以减少编译时间。<br/>
如果指定，path 将覆盖高速缓存文件的保存位置。缺省情况下，这些文件会与目标文件保存在同一目录下。当收集阶段和使用阶段出现在两个不同的位置时，指定路径便十分有用。<br/>
典型的命令序列可能是：<br/>
`demo% f95 -xO5 -xprofile=collect -xprofile_ircache t1.c t2.c`<br/>
`demo% a.out     collects feedback data`<br/>
`demo% f95 -xO5 -xprofile=use -xprofile_ircache t1.c t2.c`<br/>
对于大程序，通过用这种方式保存中间数据，可以显著缩短使用阶段的编译时间。但这将以显著增加所用的磁盘空间为代价。

- ## `–xprofile_pathmap= collect_prefix:use_prefix`

(SPARC) 设置配置文件数据文件的路径映射。<br/>
请将 -xprofile_pathmap 选项与 -xprofile=use 选项一起使用。<br/>
如果编译器找不到用-xprofile=use 编译的目标文件的配置文件数据，请使用 -xprofile_pathmap，并且：<br/>
当前使用 -xprofile=use 进行编译所用的目录，不是先前使用 -xprofile=collect 编译时使用的目录。<br/>
目标文件会共享配置文件中的公共基名，但可以根据它们在不同目录中的位置互相区分。<br/>
collect-prefix 是目录树的 UNIX 路径名的前缀，该目录树中的目标文件是使用 -xprofile=collect 编译的。<br/>
use-prefix 是目录树的 UNIX 路径名的前缀，该目录树中的目标文件是使用 -xprofile=use 编译的。<br/>
如果指定了 -xprofile_pathmap 的多个实例，编译器将按照这些实例的出现顺序对其进行处理。将 -xprofile_pathmap 实例指定的每个 use-prefix 与目标文件路径名进行比较，直至找到匹配的 use-prefix 或发现最后一个指定的 use-prefix 与目标文件路径名也不匹配。

- ## `–xrecursive`

允许不带 RECURSIVE 属性的例程以递归方式调用它们自己。<br/>
通常，只有使用 RECURSIVE 属性定义的子程序才能以递归方式调用它们自己。<br/>
使用 -xrecursive 进行编译使得子程序可以调用它们自己，即使它们没有使用 RECURSIVE 属性进行定义也是如此。但是，与定义了RECURSIVE 的子例程不同，缺省情况下，使用此标志不会导致在栈上分配局部变量。要使局部变量在子程序的每个递归调用中具有不同的值，还应该使用 -stackvar 进行编译以便将局部变量放在栈上。<br/>
间接递归（例程 A 调用例程 B，而例程 B 又调用例程 A）可在高于 -xO2 的优化级别上生成不一致的结果。使用 -xrecursive 标志进行编译，可以保证使用间接递归的正确性，即使优化级别更高也是如此。<br/>
使用 -xrecursive 进行编译会导致性能下降。

- ## `–xreduction`

与 -reduction 等效。

- ## `–xregs= r`
 
指定寄存器使用。<br/>
r 是一个逗号分隔列表，它包含以下一项或多项：<br/>
[no%]appl, [no%] float。<br/>
其中 % 已显示，它是一个必需的字符。<br/>
示例： -xregs=appl,no%float<br/>
为子选项加上前缀 no% 可禁用该功能。<br/>
appl<br/>
(SPARC) 允许编译器将应用寄存器用作临时寄存器来生成代码。在 32 位处理器上具有 g2、g3 和 g4 寄存器，在 64 位处理器上则具有g2、g3 寄存器。<br/>
float<br/>
（仅限 SPARC）允许编译器将浮点寄存器用作整数值的临时寄存器。此选项不会影响编译器为浮点值使用浮点寄存器。<br/>
no%float<br/>
不使用浮点寄存器。使用此选项时，源程序不能包含任何浮点代码。<br/>
frameptr<br/>
（仅限 x86）允许编译器将帧指针寄存器（在 32 位 x86 处理器上为 %ebp，在 64 位 x86 处理器上为 %rbp）用作未分配的被调用方保存寄存器，以提高程序性能。如果还使用 -xpg 或 -p 进行编译，则会忽略 -xregs=frameptr。<br/>
在 SPARC 平台上缺省值为 -xregs=appl,float，在 x86 上缺省值为 -xregs=appl,float,no%frameptr。<br/>
对于与应用程序链接的共享库，强烈建议您使用 -xregs=no%appl,float 来编译用于这些库的代码。至少共享库应该显式说明它如何使用应用程序寄存器，以便与这些库链接的应用程序知道如何处理该问题。<br/>
例如，在某种全局意义上使用寄存器（例如，使用寄存器指向一些关键数据结构）的应用程序，需要确切地知道其代码未使用 -xregs=no%appl编译的某个库如何使用应用程序寄存器，以便安全地与该库链接。

- ## `–xs`

允许 dbx 在没有目标 (.o) 文件的情况下进行调试。<br/>
如果使用 -xs，则所有调试信息将复制到可执行文件中。如果将可执行文件移至另一个目录，则可以使用 dbx 并忽略目标 (.o) 文件。如果不能保留 .o 文件，请使用该选项。<br/>
如果不使用 -xs，在移动可执行文件的情况下，您必须同时移动源文件和目标 (.o) 文件，或者使用 dbx pathmap 或 use 命令设置路径。

- ## `–xsafe=mem`

(SPARC) 允许编译器假定未发生违反内存保护的情况。<br/>
使用此选项可允许编译器假定未发生基于内存的陷阱。此选项允许在 SPARC V9 平台上使用推测装入指令。<br/>
仅当与优化级别 -O5 一起使用时此选项才有效。<br/>
注意 –<br/>
由于在发生诸如地址未对齐或段违规的故障时，无故障装入不会导致陷阱，因此您应该只对不会发生此类故障的程序使用该选项。因为只有很少的程序会导致基于内存的陷阱，所以您可以安全地将该选项用于大多数程序。对于显式依赖基于内存的陷阱来处理异常情况的程序，请勿使用该选项。

- ## `–xsb`

（已过时）与 -sb 等效。

- ## `–xsbfast`

（已过时）与 -sbfast 等效。

- ## `–xspace`

不执行会增加代码大小的优化。<br/>
示例： 如果增加代码大小，则不会解开循环或并行化循环。

- ## `–xtarget=t`

为指令集和优化指定目标平台。<br/>
t 必须是以下值之一： native、native64、generic、generic64 和 platform–name。<br/>
-xtarget 选项允许简便快捷地指定发生在实际平台上的 -xarch、-xchip 和 -xcache 组合。-xtarget 的唯一含义在其扩展中。<br/>
通过为编译器提供目标计算机硬件的精确描述，某些程序的性能可得到提高。当程序性能很重要时，目标硬件的正确指定是非常重要的。在较新的 SPARC 处理器上运行时，尤其是这样。不过，对大多数程序和较旧的 SPARC 处理器来讲，性能的提高微不足道，因此指定 generic 就足够了。<br/>
-xtarget 值的实际扩展可能会因发行版的不同而异。通过使用 -dryrun 标志，您始终可以确定编译器将使用的扩展：
![img](/img/in-post/2016-12-21-Fortran-compiler-options/55.png)
请注意，针对特定名称平台的 —xtarget 扩展不得与同一平台上的 —xtarget=native 相同。<br/>
通用平台与本机平台:<br/>
native<br/>
优化主机平台（32 位）的性能。<br/>
扩展至 —m32 —xarch=native —xchip=native —xcache=native<br/>
native64<br/>
已过时。改用 —xtarget=native —m64。<br/>
generic<br/>
为大多数 32 位平台获得最佳性能。<br/>
这是缺省值并可扩展至： -m32 -xarch=generic -xchip=generic -xcache=generic<br/>
generic64<br/>
已过时。改用 -xtarget=generic -m64。<br/>
platform–name<br/>
获取以下列出的指定平台的最佳性能。<br/>
SPARC 平台:<br/>
下表列出了编译器接受的常用系统平台的名称。
![img](/img/in-post/2016-12-21-Fortran-compiler-options/56.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/57.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/58.png)
-m64 标志表示针对启用了 64 位的平台上的 64 位 Solaris OS 进行编译。如果指定了 -xtarget，则 -m64 必须出现在 -xtarget 标志之后，如下所示：<br/>
`-xtarget=ultra2 ... -m64`<br/>
否则，将使用缺省的 32 位内存模型。<br/>
X86 平台:<br/>
对于 x86 系统，有效的 -xtarget 平台名称如下：<br/>
generic、native、pentium、pentium_pro、pentium3、pentium4、woodcrest、penryn、nehalem、barcelona 和opteron。<br/>
-xtarget 值（x86 平台）
![img](/img/in-post/2016-12-21-Fortran-compiler-options/59.png)
![img](/img/in-post/2016-12-21-Fortran-compiler-options/60.png)
-m64 标志表示针对启用了 64 位的 x86 平台上的 64 位 Solaris OS 进行编译。例如，使用 -xtarget=opteron 进行编译是不必要的或不够的。如果指定了 -xtarget，则 -m64 选项必须出现在 -xtarget 标志之后，如下所示：<br/>
`-xtarget=opteron -m64`<br/>
否则，编译将为 32 位 x86。

- ## `–xtime`

与 -time 等效。

- ## `–xtypemap= spec`

![img](/img/in-post/2016-12-21-Fortran-compiler-options/61.png)

- ## `–xunroll=n`

与 -unroll=n 等效。

- ## `–xvector[= [[ no%]lib, [no%] simd, %none] ]`

启用对向量库函数调用的自动生成。<br/>
在使用 -xvector 进行编译时，此选项要求使用缺省舍入模式 -fround=nearest 进行编译。<br/>
-xvector=lib（仅适用于 Solaris 平台），允许编译器将循环内的数学库调用转换为对等效向量数学例程的单个调用（如果能够进行此类转换的话）。此类转换可提高那些循环计数较大的循环的性能。-xvector=no%lib 将禁用此功能。<br/>
-xvector=simd 使得编译器可以使用本机 x86 SSE SIMD 指令来提高某些循环的性能。如果目标体系结构支持 SIMD 指令，则编译器只能接受此转换。例如，必须指定 -xarch=sse2 -m64 或 -xarch=generic64。还必须指定 -xO3 或更高的优化级别，以及 -xdepend 和 -xvector=simd。-xvector=no%simd 将禁用此功能。<br/>
如果您同时指定了 -xvector=simd 和 -fsimple=2，则可以获得比单独指定 -xvector=simd 更好的性能。但是，浮点结果可能会稍有不同，因为 -fsimple=2 允许对浮点运算重新排序。<br/>
缺省值为 -xvector=%none。如果您指定了 -xvector，但是未提供子选项，则编译器假定 -xvector=lib。<br/>
在装入步骤中，编译器会包含 libmvec 库。如果您在编译时指定了 -xvector=lib，则还必须在链接时指定它。<br/>
此选项会覆盖以前的实例，因此，-xvector=%none 会覆盖以前指定的 -xvector=lib。

- ## `–ztext`

在不重定位的情况下仅生成纯库。<br/>
-ztext 的一般用途是验证所生成的库是否为纯文本；指令都是与位置无关的代码。因此，它通常与 -G 和 -pic 一起使用。<br/>
使用 -ztext 时，如果 ld 在 text 段中找到了不完整的重定位，则不会生成库。如果它在 data 段中找到了不完整的重定位，则通常会生成库；数据段是可写入的。<br/>
不使用 -ztext 时，ld 会生成库，与有无重定位无关。<br/>
如果您不知道目标文件是否是使用 -pic 生成的，则一种典型用法是利用源文件和目标文件生成库。<br/>
示例： 利用源文件和目标文件生成库：<br/>
`demo% f95 -G -pic -ztext -o MyLib -hMyLib a.f b.f x.o y.o`<br/>
另一种用法是确认代码是否与位置无关： 不带 -pic 进行编译，但确认是否为纯文本。<br/>
示例：确认是否为纯文本－即使不带 -pic 进行编辑：<br/>
`demo% f95 -G -ztext -o MyLib -hMyLib a.f b.f x.o y.o`<br/>
选项 -ztext 和 -xprofile=collect 不应同时使用。-ztext 会阻止只读存储中与位置有关的符号重定位，而 -xprofile=collect 会在可写存储中生成静态初始化且与位置有关的符号重定位。<br/>
如果使用 -ztext 进行编译时 ld 不生成库，则可以在不使用 -ztext 的情况下重新编译，此时 ld 将生成库。使用 -ztext 生成失败意味着无法对库的一个或多个组件共享，不过，也许能共享某些其他组件。此时就产生了性能问题，这最好由您－程序员来解决。